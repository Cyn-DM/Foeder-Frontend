{"version":7,"type":"context-options","origin":"library","browserName":"chromium","options":{"noDefaultViewport":false,"viewport":{"width":1280,"height":720},"ignoreHTTPSErrors":true,"javaScriptEnabled":true,"bypassCSP":false,"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.31 Safari/537.36","locale":"en-US","offline":false,"deviceScaleFactor":1,"isMobile":false,"hasTouch":false,"colorScheme":"light","acceptDownloads":"accept","serviceWorkers":"allow"},"platform":"win32","wallTime":1732730793734,"monotonicTime":663.364,"sdkLanguage":"javascript","testIdAttributeName":"data-testid","title":"login.spec.js:16 › With stealth plugin › login"}
{"type":"event","time":774.614,"class":"BrowserContext","method":"page","params":{"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}}
{"type":"before","callId":"call@13","startTime":796.12,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('app' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      const makeError = {\\n        ErrorInInvocation: fn => {\\n          const err = new TypeError(`Error in invocation of app.${fn}()`)\\n          return utils.stripErrorWithAnchor(\\n            err,\\n            `at ${fn} (eval at <anonymous>`\\n          )\\n        }\\n      }\\n\\n      // There's a some static data in that property which doesn't seem to change,\\n      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\\n      const STATIC_DATA = JSON.parse(\\n        `\\n{\\n  \\\"isInstalled\\\": false,\\n  \\\"InstallState\\\": {\\n    \\\"DISABLED\\\": \\\"disabled\\\",\\n    \\\"INSTALLED\\\": \\\"installed\\\",\\n    \\\"NOT_INSTALLED\\\": \\\"not_installed\\\"\\n  },\\n  \\\"RunningState\\\": {\\n    \\\"CANNOT_RUN\\\": \\\"cannot_run\\\",\\n    \\\"READY_TO_RUN\\\": \\\"ready_to_run\\\",\\n    \\\"RUNNING\\\": \\\"running\\\"\\n  }\\n}\\n        `.trim()\\n      )\\n\\n      window.chrome.app = {\\n        ...STATIC_DATA,\\n\\n        get isInstalled() {\\n          return false\\n        },\\n\\n        getDetails: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getDetails`)\\n          }\\n          return null\\n        },\\n        getIsInstalled: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`getIsInstalled`)\\n          }\\n          return false\\n        },\\n        runningState: function getDetails() {\\n          if (arguments.length) {\\n            throw makeError.ErrorInInvocation(`runningState`)\\n          }\\n          return 'cannot_run'\\n        }\\n      }\\n      utils.patchToStringNested(window.chrome.app)\\n    }\",\"_args\":[]})"},"stepId":"pw:api@5","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@13"}
{"type":"before","callId":"call@15","startTime":796.883,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      if (!window.chrome) {\\n        // Use the exact property descriptor found in headful Chrome\\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n        Object.defineProperty(window, 'chrome', {\\n          writable: true,\\n          enumerable: true,\\n          configurable: false, // note!\\n          value: {} // We'll extend that later\\n        })\\n      }\\n\\n      // That means we're running headful and don't need to mock anything\\n      if ('csi' in window.chrome) {\\n        return // Nothing to do here\\n      }\\n\\n      // Check that the Navigation Timing API v1 is available, we need that\\n      if (!window.performance || !window.performance.timing) {\\n        return\\n      }\\n\\n      const { timing } = window.performance\\n\\n      window.chrome.csi = function() {\\n        return {\\n          onloadT: timing.domContentLoadedEventEnd,\\n          startE: timing.navigationStart,\\n          pageT: Date.now() - timing.navigationStart,\\n          tran: 15 // Transition type or something\\n        }\\n      }\\n      utils.patchToString(window.chrome.csi)\\n    }\",\"_args\":[]})"},"stepId":"pw:api@6","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@15"}
{"type":"before","callId":"call@17","startTime":797.3,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        if ('loadTimes' in window.chrome) {\\n          return // Nothing to do here\\n        }\\n\\n        // Check that the Navigation Timing API v1 + v2 is available, we need that\\n        if (\\n          !window.performance ||\\n          !window.performance.timing ||\\n          !window.PerformancePaintTiming\\n        ) {\\n          return\\n        }\\n\\n        const { performance } = window\\n\\n        // Some stuff is not available on about:blank as it requires a navigation to occur,\\n        // let's harden the code to not fail then:\\n        const ntEntryFallback = {\\n          nextHopProtocol: 'h2',\\n          type: 'other'\\n        }\\n\\n        // The API exposes some funky info regarding the connection\\n        const protocolInfo = {\\n          get connectionInfo() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.nextHopProtocol\\n          },\\n          get npnNegotiatedProtocol() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n              ? ntEntry.nextHopProtocol\\n              : 'unknown'\\n          },\\n          get navigationType() {\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ntEntry.type\\n          },\\n          get wasAlternateProtocolAvailable() {\\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\\n            // should always return false.\\n            return false\\n          },\\n          get wasFetchedViaSpdy() {\\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          },\\n          get wasNpnNegotiated() {\\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\\n            const ntEntry =\\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\\n          }\\n        }\\n\\n        const { timing } = window.performance\\n\\n        // Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\\n        function toFixed(num, fixed) {\\n          var re = new RegExp('^-?\\\\\\\\d+(?:.\\\\\\\\d{0,' + (fixed || -1) + '})?')\\n          return num.toString().match(re)[0]\\n        }\\n\\n        const timingInfo = {\\n          get firstPaintAfterLoadTime() {\\n            // This was never actually implemented and always returns 0.\\n            return 0\\n          },\\n          get requestTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get startLoadTime() {\\n            return timing.navigationStart / 1000\\n          },\\n          get commitLoadTime() {\\n            return timing.responseStart / 1000\\n          },\\n          get finishDocumentLoadTime() {\\n            return timing.domContentLoadedEventEnd / 1000\\n          },\\n          get finishLoadTime() {\\n            return timing.loadEventEnd / 1000\\n          },\\n          get firstPaintTime() {\\n            const fpEntry = performance.getEntriesByType('paint')[0] || {\\n              startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\\n            }\\n            return toFixed(\\n              (fpEntry.startTime + performance.timeOrigin) / 1000,\\n              3\\n            )\\n          }\\n        }\\n\\n        window.chrome.loadTimes = function() {\\n          return {\\n            ...protocolInfo,\\n            ...timingInfo\\n          }\\n        }\\n        utils.patchToString(window.chrome.loadTimes)\\n      }\",\"_args\":[{\"opts\":{}}]})"},"stepId":"pw:api@7","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@17"}
{"type":"before","callId":"call@19","startTime":797.782,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts, STATIC_DATA }) => {\\n        if (!window.chrome) {\\n          // Use the exact property descriptor found in headful Chrome\\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\\n          Object.defineProperty(window, 'chrome', {\\n            writable: true,\\n            enumerable: true,\\n            configurable: false, // note!\\n            value: {} // We'll extend that later\\n          })\\n        }\\n\\n        // That means we're running headful and don't need to mock anything\\n        const existsAlready = 'runtime' in window.chrome\\n        // `chrome.runtime` is only exposed on secure origins\\n        const isNotSecure = !window.location.protocol.startsWith('https')\\n        if (existsAlready || (isNotSecure && !opts.runOnInsecureOrigins)) {\\n          return // Nothing to do here\\n        }\\n\\n        window.chrome.runtime = {\\n          // There's a bunch of static data in that property which doesn't seem to change,\\n          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\\n          ...STATIC_DATA,\\n          // `chrome.runtime.id` is extension related and returns undefined in Chrome\\n          get id() {\\n            return undefined\\n          },\\n          // These two require more sophisticated mocks\\n          connect: null,\\n          sendMessage: null\\n        }\\n\\n        const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({\\n          NoMatchingSignature: new TypeError(\\n            preamble + `No matching signature.`\\n          ),\\n          MustSpecifyExtensionID: new TypeError(\\n            preamble +\\n              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`\\n          ),\\n          InvalidExtensionID: new TypeError(\\n            preamble + `Invalid extension id: '${extensionId}'`\\n          )\\n        })\\n\\n        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\\n        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\\n        const isValidExtensionID = str =>\\n          str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)\\n\\n        /** Mock `chrome.runtime.sendMessage` */\\n        const sendMessageHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, options, responseCallback] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.sendMessage()`,\\n              extensionId\\n            )\\n\\n            // Check if the call signature looks ok\\n            const noArguments = args.length === 0\\n            const tooManyArguments = args.length > 4\\n            const incorrectOptions = options && typeof options !== 'object'\\n            const incorrectResponseCallback =\\n              responseCallback && typeof responseCallback !== 'function'\\n            if (\\n              noArguments ||\\n              tooManyArguments ||\\n              incorrectOptions ||\\n              incorrectResponseCallback\\n            ) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            // At least 2 arguments are required before we even validate the extension ID\\n            if (args.length < 2) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Now let's make sure we got a string as extension ID\\n            if (typeof extensionId !== 'string') {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            if (!isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            return undefined // Normal behavior\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'sendMessage',\\n          function sendMessage() {},\\n          sendMessageHandler\\n        )\\n\\n        /**\\n         * Mock `chrome.runtime.connect`\\n         *\\n         * @see https://developer.chrome.com/apps/runtime#method-connect\\n         */\\n        const connectHandler = {\\n          apply: function(target, ctx, args) {\\n            const [extensionId, connectInfo] = args || []\\n\\n            // Define custom errors\\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\\n            const Errors = makeCustomRuntimeErrors(\\n              errorPreamble,\\n              `chrome.runtime.connect()`,\\n              extensionId\\n            )\\n\\n            // Behavior differs a bit from sendMessage:\\n            const noArguments = args.length === 0\\n            const emptyStringArgument = args.length === 1 && extensionId === ''\\n            if (noArguments || emptyStringArgument) {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            const tooManyArguments = args.length > 2\\n            const incorrectConnectInfoType =\\n              connectInfo && typeof connectInfo !== 'object'\\n\\n            if (tooManyArguments || incorrectConnectInfoType) {\\n              throw Errors.NoMatchingSignature\\n            }\\n\\n            const extensionIdIsString = typeof extensionId === 'string'\\n            if (extensionIdIsString && extensionId === '') {\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n            if (extensionIdIsString && !isValidExtensionID(extensionId)) {\\n              throw Errors.InvalidExtensionID\\n            }\\n\\n            // There's another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\\n            const validateConnectInfo = ci => {\\n              // More than a first param connectInfo as been provided\\n              if (args.length > 1) {\\n                throw Errors.NoMatchingSignature\\n              }\\n              // An empty connectInfo has been provided\\n              if (Object.keys(ci).length === 0) {\\n                throw Errors.MustSpecifyExtensionID\\n              }\\n              // Loop over all connectInfo props an check them\\n              Object.entries(ci).forEach(([k, v]) => {\\n                const isExpected = ['name', 'includeTlsChannelId'].includes(k)\\n                if (!isExpected) {\\n                  throw new TypeError(\\n                    errorPreamble + `Unexpected property: '${k}'.`\\n                  )\\n                }\\n                const MismatchError = (propName, expected, found) =>\\n                  TypeError(\\n                    errorPreamble +\\n                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`\\n                  )\\n                if (k === 'name' && typeof v !== 'string') {\\n                  throw MismatchError(k, 'string', typeof v)\\n                }\\n                if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {\\n                  throw MismatchError(k, 'boolean', typeof v)\\n                }\\n              })\\n            }\\n            if (typeof extensionId === 'object') {\\n              validateConnectInfo(extensionId)\\n              throw Errors.MustSpecifyExtensionID\\n            }\\n\\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\\n            return utils.patchToStringNested(makeConnectResponse())\\n          }\\n        }\\n        utils.mockWithProxy(\\n          window.chrome.runtime,\\n          'connect',\\n          function connect() {},\\n          connectHandler\\n        )\\n\\n        function makeConnectResponse() {\\n          const onSomething = () => ({\\n            addListener: function addListener() {},\\n            dispatch: function dispatch() {},\\n            hasListener: function hasListener() {},\\n            hasListeners: function hasListeners() {\\n              return false\\n            },\\n            removeListener: function removeListener() {}\\n          })\\n\\n          const response = {\\n            name: '',\\n            sender: undefined,\\n            disconnect: function disconnect() {},\\n            onDisconnect: onSomething(),\\n            onMessage: onSomething(),\\n            postMessage: function postMessage() {\\n              if (!arguments.length) {\\n                throw new TypeError(`Insufficient number of arguments.`)\\n              }\\n              throw new Error(`Attempting to use a disconnected port object`)\\n            }\\n          }\\n          return response\\n        }\\n      }\",\"_args\":[{\"opts\":{\"runOnInsecureOrigins\":false},\"STATIC_DATA\":{\"OnInstalledReason\":{\"CHROME_UPDATE\":\"chrome_update\",\"INSTALL\":\"install\",\"SHARED_MODULE_UPDATE\":\"shared_module_update\",\"UPDATE\":\"update\"},\"OnRestartRequiredReason\":{\"APP_UPDATE\":\"app_update\",\"OS_UPDATE\":\"os_update\",\"PERIODIC\":\"periodic\"},\"PlatformArch\":{\"ARM\":\"arm\",\"ARM64\":\"arm64\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformNaclArch\":{\"ARM\":\"arm\",\"MIPS\":\"mips\",\"MIPS64\":\"mips64\",\"X86_32\":\"x86-32\",\"X86_64\":\"x86-64\"},\"PlatformOs\":{\"ANDROID\":\"android\",\"CROS\":\"cros\",\"LINUX\":\"linux\",\"MAC\":\"mac\",\"OPENBSD\":\"openbsd\",\"WIN\":\"win\"},\"RequestUpdateCheckStatus\":{\"NO_UPDATE\":\"no_update\",\"THROTTLED\":\"throttled\",\"UPDATE_AVAILABLE\":\"update_available\"}}}]})"},"stepId":"pw:api@8","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@19"}
{"type":"before","callId":"call@21","startTime":798.377,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"utils => {\\n      /**\\n       * Input might look funky, we need to normalize it so e.g. whitespace isn't an issue for our spoofing.\\n       *\\n       * @example\\n       * video/webm; codecs=\\\"vp8, vorbis\\\"\\n       * video/mp4; codecs=\\\"avc1.42E01E\\\"\\n       * audio/x-m4a;\\n       * audio/ogg; codecs=\\\"vorbis\\\"\\n       * @param {String} arg\\n       */\\n      const parseInput = arg => {\\n        const [mime, codecStr] = arg.trim().split(';')\\n        let codecs = []\\n        if (codecStr && codecStr.includes('codecs=\\\"')) {\\n          codecs = codecStr\\n            .trim()\\n            .replace(`codecs=\\\"`, '')\\n            .replace(`\\\"`, '')\\n            .trim()\\n            .split(',')\\n            .filter(x => !!x)\\n            .map(x => x.trim())\\n        }\\n        return {\\n          mime,\\n          codecStr,\\n          codecs\\n        }\\n      }\\n\\n      const canPlayType = {\\n        // Intercept certain requests\\n        apply: function(target, ctx, args) {\\n          if (!args || !args.length) {\\n            return target.apply(ctx, args)\\n          }\\n          const { mime, codecs } = parseInput(args[0])\\n          // This specific mp4 codec is missing in Chromium\\n          if (mime === 'video/mp4') {\\n            if (codecs.includes('avc1.42E01E')) {\\n              return 'probably'\\n            }\\n          }\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/x-m4a' && !codecs.length) {\\n            return 'maybe'\\n          }\\n\\n          // This mimetype is only supported if no codecs are specified\\n          if (mime === 'audio/aac' && !codecs.length) {\\n            return 'probably'\\n          }\\n          // Everything else as usual\\n          return target.apply(ctx, args)\\n        }\\n      }\\n\\n      /* global HTMLMediaElement */\\n      utils.replaceWithProxy(\\n        HTMLMediaElement.prototype,\\n        'canPlayType',\\n        canPlayType\\n      )\\n    }\",\"_args\":[]})"},"stepId":"pw:api@9","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@21"}
{"type":"before","callId":"call@23","startTime":798.794,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'hardwareConcurrency',\\n          utils.makeHandler().getterValue(opts.hardwareConcurrency)\\n        )\\n      }\",\"_args\":[{\"opts\":{\"hardwareConcurrency\":4}}]})"},"stepId":"pw:api@10","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@23"}
{"type":"before","callId":"call@25","startTime":799.207,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { opts }) => {\\n        const languages = opts.languages.length\\n          ? opts.languages\\n          : ['en-US', 'en']\\n        utils.replaceGetterWithProxy(\\n          Object.getPrototypeOf(navigator),\\n          'languages',\\n          utils.makeHandler().getterValue(Object.freeze([...languages]))\\n        )\\n      }\",\"_args\":[{\"opts\":{\"languages\":[]}}]})"},"stepId":"pw:api@11","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@25"}
{"type":"before","callId":"call@27","startTime":799.61,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const isSecure = document.location.protocol.startsWith('https')\\n\\n      // In headful on secure origins the permission should be \\\"default\\\", not \\\"denied\\\"\\n      if (isSecure) {\\n        utils.replaceGetterWithProxy(Notification, 'permission', {\\n          apply() {\\n            return 'default'\\n          }\\n        })\\n      }\\n\\n      // Another weird behavior:\\n      // On insecure origins in headful the state is \\\"denied\\\",\\n      // whereas in headless it's \\\"prompt\\\"\\n      if (!isSecure) {\\n        const handler = {\\n          apply(target, ctx, args) {\\n            const param = (args || [])[0]\\n\\n            const isNotifications =\\n              param && param.name && param.name === 'notifications'\\n            if (!isNotifications) {\\n              return utils.cache.Reflect.apply(...arguments)\\n            }\\n\\n            return Promise.resolve(\\n              Object.setPrototypeOf(\\n                {\\n                  state: 'denied',\\n                  onchange: null\\n                },\\n                PermissionStatus.prototype\\n              )\\n            )\\n          }\\n        }\\n        // Note: Don't use `Object.getPrototypeOf` here\\n        utils.replaceWithProxy(Permissions.prototype, 'query', handler)\\n      }\\n    }\",\"_args\":[{}]})"},"stepId":"pw:api@12","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@27"}
{"type":"before","callId":"call@29","startTime":800.002,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, { fns, data }) => {\\n        fns = utils.materializeFns(fns)\\n\\n        // That means we're running headful\\n        const hasPlugins = 'plugins' in navigator && navigator.plugins.length\\n        if (hasPlugins) {\\n          return // nothing to do here\\n        }\\n\\n        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)\\n        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)\\n\\n        // Plugin and MimeType cross-reference each other, let's do that now\\n        // Note: We're looping through `data.plugins` here, not the generated `plugins`\\n        for (const pluginData of data.plugins) {\\n          pluginData.__mimeTypes.forEach((type, index) => {\\n            plugins[pluginData.name][index] = mimeTypes[type]\\n\\n            Object.defineProperty(plugins[pluginData.name], type, {\\n              value: mimeTypes[type],\\n              writable: false,\\n              enumerable: false, // Not enumerable\\n              configurable: true\\n            })\\n            Object.defineProperty(mimeTypes[type], 'enabledPlugin', {\\n              value:\\n                type === 'application/x-pnacl'\\n                  ? mimeTypes['application/x-nacl'].enabledPlugin // these reference the same plugin, so we need to re-use the Proxy in order to avoid leaks\\n                  : new Proxy(plugins[pluginData.name], {}), // Prevent circular references\\n              writable: false,\\n              enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\\n              configurable: true\\n            })\\n          })\\n        }\\n\\n        const patchNavigator = (name, value) =>\\n          utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\\n            get() {\\n              return value\\n            }\\n          })\\n\\n        patchNavigator('mimeTypes', mimeTypes)\\n        patchNavigator('plugins', plugins)\\n\\n        // All done\\n      }\",\"_args\":[{\"fns\":{\"generateMimeTypeArray\":\"(utils, fns) => mimeTypesData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    mimeTypesData,\\n    MimeTypeArray.prototype,\\n    MimeType.prototype,\\n    'type'\\n  )\\n}\",\"generatePluginArray\":\"(utils, fns) => pluginsData => {\\n  return fns.generateMagicArray(utils, fns)(\\n    pluginsData,\\n    PluginArray.prototype,\\n    Plugin.prototype,\\n    'name'\\n  )\\n}\",\"generateMagicArray\":\"(utils, fns) =>\\n  function(\\n    dataArray = [],\\n    proto = MimeTypeArray.prototype,\\n    itemProto = MimeType.prototype,\\n    itemMainProp = 'type'\\n  ) {\\n    // Quick helper to set props with the same descriptors vanilla is using\\n    const defineProp = (obj, prop, value) =>\\n      Object.defineProperty(obj, prop, {\\n        value,\\n        writable: false,\\n        enumerable: false, // Important for mimeTypes & plugins: `JSON.stringify(navigator.mimeTypes)`\\n        configurable: true\\n      })\\n\\n    // Loop over our fake data and construct items\\n    const makeItem = data => {\\n      const item = {}\\n      for (const prop of Object.keys(data)) {\\n        if (prop.startsWith('__')) {\\n          continue\\n        }\\n        defineProp(item, prop, data[prop])\\n      }\\n      return patchItem(item, data)\\n    }\\n\\n    const patchItem = (item, data) => {\\n      let descriptor = Object.getOwnPropertyDescriptors(item)\\n\\n      // Special case: Plugins have a magic length property which is not enumerable\\n      // e.g. `navigator.plugins[i].length` should always be the length of the assigned mimeTypes\\n      if (itemProto === Plugin.prototype) {\\n        descriptor = {\\n          ...descriptor,\\n          length: {\\n            value: data.__mimeTypes.length,\\n            writable: false,\\n            enumerable: false,\\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n          }\\n        }\\n      }\\n\\n      // We need to spoof a specific `MimeType` or `Plugin` object\\n      const obj = Object.create(itemProto, descriptor)\\n\\n      // Virtually all property keys are not enumerable in vanilla\\n      const blacklist = [...Object.keys(data), 'length', 'enabledPlugin']\\n      return new Proxy(obj, {\\n        ownKeys(target) {\\n          return Reflect.ownKeys(target).filter(k => !blacklist.includes(k))\\n        },\\n        getOwnPropertyDescriptor(target, prop) {\\n          if (blacklist.includes(prop)) {\\n            return undefined\\n          }\\n          return Reflect.getOwnPropertyDescriptor(target, prop)\\n        }\\n      })\\n    }\\n\\n    const magicArray = []\\n\\n    // Loop through our fake data and use that to create convincing entities\\n    dataArray.forEach(data => {\\n      magicArray.push(makeItem(data))\\n    })\\n\\n    // Add direct property access  based on types (e.g. `obj['application/pdf']`) afterwards\\n    magicArray.forEach(entry => {\\n      defineProp(magicArray, entry[itemMainProp], entry)\\n    })\\n\\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\\n    const magicArrayObj = Object.create(proto, {\\n      ...Object.getOwnPropertyDescriptors(magicArray),\\n\\n      // There's one ugly quirk we unfortunately need to take care of:\\n      // The `MimeTypeArray` prototype has an enumerable `length` property,\\n      // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\\n      // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\\n      length: {\\n        value: magicArray.length,\\n        writable: false,\\n        enumerable: false,\\n        configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\\n      }\\n    })\\n\\n    // Generate our functional function mocks :-)\\n    const functionMocks = fns.generateFunctionMocks(utils)(\\n      proto,\\n      itemMainProp,\\n      magicArray\\n    )\\n\\n    // We need to overlay our custom object with a JS Proxy\\n    const magicArrayObjProxy = new Proxy(magicArrayObj, {\\n      get(target, key = '') {\\n        // Redirect function calls to our custom proxied versions mocking the vanilla behavior\\n        if (key === 'item') {\\n          return functionMocks.item\\n        }\\n        if (key === 'namedItem') {\\n          return functionMocks.namedItem\\n        }\\n        if (proto === PluginArray.prototype && key === 'refresh') {\\n          return functionMocks.refresh\\n        }\\n        // Everything else can pass through as normal\\n        return utils.cache.Reflect.get(...arguments)\\n      },\\n      ownKeys(target) {\\n        // There are a couple of quirks where the original property demonstrates \\\"magical\\\" behavior that makes no sense\\n        // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\\n        // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\\n        // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\\n        // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj['application/pdf']`) are missing\\n        const keys = []\\n        const typeProps = magicArray.map(mt => mt[itemMainProp])\\n        typeProps.forEach((_, i) => keys.push(`${i}`))\\n        typeProps.forEach(propName => keys.push(propName))\\n        return keys\\n      },\\n      getOwnPropertyDescriptor(target, prop) {\\n        if (prop === 'length') {\\n          return undefined\\n        }\\n        return Reflect.getOwnPropertyDescriptor(target, prop)\\n      }\\n    })\\n\\n    return magicArrayObjProxy\\n  }\",\"generateFunctionMocks\":\"utils => (\\n  proto,\\n  itemMainProp,\\n  dataArray\\n) => ({\\n  /** Returns the MimeType object with the specified index. */\\n  item: utils.createProxy(proto.item, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'item' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      // Special behavior alert:\\n      // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\\n      // - If anything else than an integer (including as string) is provided it will return the first entry\\n      const isInteger = args[0] && Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\\n      // Note: Vanilla never returns `undefined`\\n      return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\\n    }\\n  }),\\n  /** Returns the MimeType object with the specified name. */\\n  namedItem: utils.createProxy(proto.namedItem, {\\n    apply(target, ctx, args) {\\n      if (!args.length) {\\n        throw new TypeError(\\n          `Failed to execute 'namedItem' on '${\\n            proto[Symbol.toStringTag]\\n          }': 1 argument required, but only 0 present.`\\n        )\\n      }\\n      return dataArray.find(mt => mt[itemMainProp] === args[0]) || null // Not `undefined`!\\n    }\\n  }),\\n  /** Does nothing and shall return nothing */\\n  refresh: proto.refresh\\n    ? utils.createProxy(proto.refresh, {\\n        apply(target, ctx, args) {\\n          return undefined\\n        }\\n      })\\n    : undefined\\n})\"},\"data\":{\"mimeTypes\":[{\"type\":\"application/pdf\",\"suffixes\":\"pdf\",\"description\":\"\",\"__pluginName\":\"Chrome PDF Viewer\"},{\"type\":\"application/x-google-chrome-pdf\",\"suffixes\":\"pdf\",\"description\":\"Portable Document Format\",\"__pluginName\":\"Chrome PDF Plugin\"},{\"type\":\"application/x-nacl\",\"suffixes\":\"\",\"description\":\"Native Client Executable\",\"__pluginName\":\"Native Client\"},{\"type\":\"application/x-pnacl\",\"suffixes\":\"\",\"description\":\"Portable Native Client Executable\",\"__pluginName\":\"Native Client\"}],\"plugins\":[{\"name\":\"Chrome PDF Plugin\",\"filename\":\"internal-pdf-viewer\",\"description\":\"Portable Document Format\",\"__mimeTypes\":[\"application/x-google-chrome-pdf\"]},{\"name\":\"Chrome PDF Viewer\",\"filename\":\"mhjfbmdgcfjbbpaeojofohoefgiehjai\",\"description\":\"\",\"__mimeTypes\":[\"application/pdf\"]},{\"name\":\"Native Client\",\"filename\":\"internal-nacl-plugin\",\"description\":\"\",\"__mimeTypes\":[\"application/x-nacl\",\"application/x-pnacl\"]}]}}]})"},"stepId":"pw:api@13","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@29"}
{"type":"before","callId":"call@31","startTime":800.518,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(() => {\n      if (navigator.webdriver === false) {\n        // Post Chrome 89.0.4339.0 and already good\n      } else if (navigator.webdriver === undefined) {\n        // Pre Chrome 89.0.4339.0 and already good\n      } else {\n        // Pre Chrome 88.0.4291.0 and needs patching\n        delete Object.getPrototypeOf(navigator).webdriver\n      }\n    })(undefined)"},"stepId":"pw:api@14","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@31"}
{"type":"before","callId":"call@33","startTime":800.842,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      const getParameterProxyHandler = {\\n        apply: function(target, ctx, args) {\\n          const param = (args || [])[0]\\n          const result = utils.cache.Reflect.apply(target, ctx, args)\\n          // UNMASKED_VENDOR_WEBGL\\n          if (param === 37445) {\\n            return opts.vendor || 'Intel Inc.' // default in headless: Google Inc.\\n          }\\n          // UNMASKED_RENDERER_WEBGL\\n          if (param === 37446) {\\n            return opts.renderer || 'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader\\n          }\\n          return result\\n        }\\n      }\\n\\n      // There's more than one WebGL rendering context\\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\\n      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\\n      const addProxy = (obj, propName) => {\\n        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\\n      }\\n      // For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:\\n      addProxy(WebGLRenderingContext.prototype, 'getParameter')\\n      addProxy(WebGL2RenderingContext.prototype, 'getParameter')\\n    }\",\"_args\":[{}]})"},"stepId":"pw:api@15","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@33"}
{"type":"before","callId":"call@35","startTime":801.237,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(() => {\n      try {\n        if (window.outerWidth && window.outerHeight) {\n          return // nothing to do here\n        }\n        const windowFrame = 85 // probably OS and WM dependent\n        window.outerWidth = window.innerWidth\n        window.outerHeight = window.innerHeight + windowFrame\n      } catch (err) {}\n    })(undefined)"},"stepId":"pw:api@16","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@35"}
{"type":"before","callId":"call@37","startTime":801.549,"apiName":"page.addInitScript","class":"Page","method":"addInitScript","params":{"source":"(({ _utilsFns, _mainFunction, _args }) => {\n        // Add this point we cannot use our utililty functions as they're just strings, we need to materialize them first\n        const utils = Object.fromEntries(\n          Object.entries(_utilsFns).map(([key, value]) => [key, eval(value)]) // eslint-disable-line no-eval\n        )\n        utils.init()\n        return eval(_mainFunction)(utils, ..._args) // eslint-disable-line no-eval\n      })({\"_utilsFns\":{\"init\":\"() => {\\n  utils.preloadCache()\\n}\",\"stripProxyFromErrors\":\"(handler = {}) => {\\n  const newHandler = {\\n    setPrototypeOf: function (target, proto) {\\n      if (proto === null)\\n        throw new TypeError('Cannot convert object to primitive value')\\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\\n        throw new TypeError('Cyclic __proto__ value')\\n      }\\n      return Reflect.setPrototypeOf(target, proto)\\n    }\\n  }\\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\\n  const traps = Object.getOwnPropertyNames(handler)\\n  traps.forEach(trap => {\\n    newHandler[trap] = function () {\\n      try {\\n        // Forward the call to the defined proxy handler\\n        return handler[trap].apply(this, arguments || [])\\n      } catch (err) {\\n        // Stack traces differ per browser, we only support chromium based ones currently\\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\\n          throw err\\n        }\\n\\n        // When something throws within one of our traps the Proxy will show up in error stacks\\n        // An earlier implementation of this code would simply strip lines with a blacklist,\\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\\n        // We try to use a known \\\"anchor\\\" line for that and strip it with everything above it.\\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\\n\\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\\n          const blacklist = [\\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\\n          ]\\n          return (\\n            err.stack\\n              .split('\\\\n')\\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\\n              .filter((line, index) => !(index === 1 && stripFirstLine))\\n              // Check if the line starts with one of our blacklisted strings\\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\\n              .join('\\\\n')\\n          )\\n        }\\n\\n        const stripWithAnchor = (stack, anchor) => {\\n          const stackArr = stack.split('\\\\n')\\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\\n          const anchorIndex = stackArr.findIndex(line =>\\n            line.trim().startsWith(anchor)\\n          )\\n          if (anchorIndex === -1) {\\n            return false // 404, anchor not found\\n          }\\n          // Strip everything from the top until we reach the anchor line\\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n          stackArr.splice(1, anchorIndex)\\n          return stackArr.join('\\\\n')\\n        }\\n\\n        // Special cases due to our nested toString proxies\\n        err.stack = err.stack.replace(\\n          'at Object.toString (',\\n          'at Function.toString ('\\n        )\\n        if ((err.stack || '').includes('at Function.toString (')) {\\n          err.stack = stripWithBlacklist(err.stack, false)\\n          throw err\\n        }\\n\\n        // Try using the anchor method, fallback to blacklist if necessary\\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\\n\\n        throw err // Re-throw our now sanitized error\\n      }\\n    }\\n  })\\n  return newHandler\\n}\",\"stripErrorWithAnchor\":\"(err, anchor) => {\\n  const stackArr = err.stack.split('\\\\n')\\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\\n  if (anchorIndex === -1) {\\n    return err // 404, anchor not found\\n  }\\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\\n  stackArr.splice(1, anchorIndex)\\n  err.stack = stackArr.join('\\\\n')\\n  return err\\n}\",\"replaceProperty\":\"(obj, propName, descriptorOverrides = {}) => {\\n  return Object.defineProperty(obj, propName, {\\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\\n    // Add our overrides (e.g. value, get())\\n    ...descriptorOverrides\\n  })\\n}\",\"preloadCache\":\"() => {\\n  if (utils.cache) {\\n    return\\n  }\\n  utils.cache = {\\n    // Used in our proxies\\n    Reflect: {\\n      get: Reflect.get.bind(Reflect),\\n      apply: Reflect.apply.bind(Reflect)\\n    },\\n    // Used in `makeNativeString`\\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\\n  }\\n}\",\"makeNativeString\":\"(name = '') => {\\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\\n}\",\"patchToString\":\"(obj, str = '') => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === obj) {\\n        // We either return the optional string verbatim or derive the most desired result automatically\\n        return str || utils.makeNativeString(obj.name)\\n      }\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"patchToStringNested\":\"(obj = {}) => {\\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\\n}\",\"redirectToString\":\"(proxyObj, originalObj) => {\\n  const handler = {\\n    apply: function (target, ctx) {\\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \\\"\\\"`\\n      if (ctx === Function.prototype.toString) {\\n        return utils.makeNativeString('toString')\\n      }\\n\\n      // `toString` targeted at our proxied Object detected\\n      if (ctx === proxyObj) {\\n        const fallback = () =>\\n          originalObj && originalObj.name\\n            ? utils.makeNativeString(originalObj.name)\\n            : utils.makeNativeString(proxyObj.name)\\n\\n        // Return the toString representation of our original object if possible\\n        return originalObj + '' || fallback()\\n      }\\n\\n      if (typeof ctx === 'undefined' || ctx === null) {\\n        return target.call(ctx)\\n      }\\n\\n      // Check if the toString protype of the context is the same as the global prototype,\\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\\n      const hasSameProto = Object.getPrototypeOf(\\n        Function.prototype.toString\\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\\n      if (!hasSameProto) {\\n        // Pass the call on to the local Function.prototype.toString instead\\n        return ctx.toString()\\n      }\\n\\n      return target.call(ctx)\\n    }\\n  }\\n\\n  const toStringProxy = new Proxy(\\n    Function.prototype.toString,\\n    utils.stripProxyFromErrors(handler)\\n  )\\n  utils.replaceProperty(Function.prototype, 'toString', {\\n    value: toStringProxy\\n  })\\n}\",\"replaceWithProxy\":\"(obj, propName, handler) => {\\n  const originalObj = obj[propName]\\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.redirectToString(proxyObj, originalObj)\\n\\n  return true\\n}\",\"replaceGetterWithProxy\":\"(obj, propName, handler) => {\\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\\n  const fnStr = fn.toString() // special getter function string\\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { get: proxyObj })\\n  utils.patchToString(proxyObj, fnStr)\\n\\n  return true\\n}\",\"replaceGetterSetter\":\"(obj, propName, handlerGetterSetter) => {\\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\\n  const handler = { ...ownPropertyDescriptor }\\n\\n  if (handlerGetterSetter.get !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.get\\n    handler.get = function() {\\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.get, nativeFn)\\n  }\\n\\n  if (handlerGetterSetter.set !== undefined) {\\n    const nativeFn = ownPropertyDescriptor.set\\n    handler.set = function(newValue) {\\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\\n    }\\n    utils.redirectToString(handler.set, nativeFn)\\n  }\\n\\n  Object.defineProperty(obj, propName, handler)\\n}\",\"mockWithProxy\":\"(obj, propName, pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n\\n  utils.replaceProperty(obj, propName, { value: proxyObj })\\n  utils.patchToString(proxyObj)\\n\\n  return true\\n}\",\"createProxy\":\"(pseudoTarget, handler) => {\\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\\n  utils.patchToString(proxyObj)\\n\\n  return proxyObj\\n}\",\"splitObjPath\":\"objPath => ({\\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\\n  objName: objPath.split('.').slice(0, -1).join('.'),\\n  // Extract last dot entry ==> `canPlayType`\\n  propName: objPath.split('.').slice(-1)[0]\\n})\",\"replaceObjPathWithProxy\":\"(objPath, handler) => {\\n  const { objName, propName } = utils.splitObjPath(objPath)\\n  const obj = eval(objName) // eslint-disable-line no-eval\\n  return utils.replaceWithProxy(obj, propName, handler)\\n}\",\"execRecursively\":\"(obj = {}, typeFilter = [], fn) => {\\n  function recurse(obj) {\\n    for (const key in obj) {\\n      if (obj[key] === undefined) {\\n        continue\\n      }\\n      if (obj[key] && typeof obj[key] === 'object') {\\n        recurse(obj[key])\\n      } else {\\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\\n          fn.call(this, obj[key])\\n        }\\n      }\\n    }\\n  }\\n  recurse(obj)\\n  return obj\\n}\",\"stringifyFns\":\"(fnObj = { hello: () => 'world' }) => {\\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\\n  // https://github.com/feross/fromentries\\n  function fromEntries(iterable) {\\n    return [...iterable].reduce((obj, [key, val]) => {\\n      obj[key] = val\\n      return obj\\n    }, {})\\n  }\\n  return (Object.fromEntries || fromEntries)(\\n    Object.entries(fnObj)\\n      .filter(([key, value]) => typeof value === 'function')\\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\\n  )\\n}\",\"materializeFns\":\"(fnStrObj = { hello: \\\"() => 'world'\\\" }) => {\\n  return Object.fromEntries(\\n    Object.entries(fnStrObj).map(([key, value]) => {\\n      if (value.startsWith('function')) {\\n        // some trickery is needed to make oldschool functions work :-)\\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\\n      } else {\\n        // arrow functions just work\\n        return [key, eval(value)] // eslint-disable-line no-eval\\n      }\\n    })\\n  )\\n}\",\"makeHandler\":\"() => ({\\n  // Used by simple `navigator` getter evasions\\n  getterValue: value => ({\\n    apply(target, ctx, args) {\\n      // Let's fetch the value first, to trigger and escalate potential errors\\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\\n      utils.cache.Reflect.apply(...arguments)\\n      return value\\n    }\\n  })\\n})\",\"arrayEquals\":\"(array1, array2) => {\\n  if (array1.length !== array2.length) {\\n    return false\\n  }\\n  for (let i = 0; i < array1.length; ++i) {\\n    if (array1[i] !== array2[i]) {\\n      return false\\n    }\\n  }\\n  return true\\n}\",\"memoize\":\"fn => {\\n  const cache = []\\n  return function(...args) {\\n    if (!cache.some(c => utils.arrayEquals(c.key, args))) {\\n      cache.push({ key: args, value: fn.apply(this, args) })\\n    }\\n    return cache.find(c => utils.arrayEquals(c.key, args)).value\\n  }\\n}\"},\"_mainFunction\":\"(utils, opts) => {\\n      try {\\n        // Adds a contentWindow proxy to the provided iframe element\\n        const addContentWindowProxy = iframe => {\\n          const contentWindowProxy = {\\n            get(target, key) {\\n              // Now to the interesting part:\\n              // We actually make this thing behave like a regular iframe window,\\n              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\\n              // That makes it possible for these assertions to be correct:\\n              // iframe.contentWindow.self === window.top // must be false\\n              if (key === 'self') {\\n                return this\\n              }\\n              // iframe.contentWindow.frameElement === iframe // must be true\\n              if (key === 'frameElement') {\\n                return iframe\\n              }\\n              // Intercept iframe.contentWindow[0] to hide the property 0 added by the proxy.\\n              if (key === '0') {\\n                return undefined\\n              }\\n              return Reflect.get(target, key)\\n            }\\n          }\\n\\n          if (!iframe.contentWindow) {\\n            const proxy = new Proxy(window, contentWindowProxy)\\n            Object.defineProperty(iframe, 'contentWindow', {\\n              get() {\\n                return proxy\\n              },\\n              set(newValue) {\\n                return newValue // contentWindow is immutable\\n              },\\n              enumerable: true,\\n              configurable: false\\n            })\\n          }\\n        }\\n\\n        // Handles iframe element creation, augments `srcdoc` property so we can intercept further\\n        const handleIframeCreation = (target, thisArg, args) => {\\n          const iframe = target.apply(thisArg, args)\\n\\n          // We need to keep the originals around\\n          const _iframe = iframe\\n          const _srcdoc = _iframe.srcdoc\\n\\n          // Add hook for the srcdoc property\\n          // We need to be very surgical here to not break other iframes by accident\\n          Object.defineProperty(iframe, 'srcdoc', {\\n            configurable: true, // Important, so we can reset this later\\n            get: function() {\\n              return _srcdoc\\n            },\\n            set: function(newValue) {\\n              addContentWindowProxy(this)\\n              // Reset property, the hook is only needed once\\n              Object.defineProperty(iframe, 'srcdoc', {\\n                configurable: false,\\n                writable: false,\\n                value: _srcdoc\\n              })\\n              _iframe.srcdoc = newValue\\n            }\\n          })\\n          return iframe\\n        }\\n\\n        // Adds a hook to intercept iframe creation events\\n        const addIframeCreationSniffer = () => {\\n          /* global document */\\n          const createElementHandler = {\\n            // Make toString() native\\n            get(target, key) {\\n              return Reflect.get(target, key)\\n            },\\n            apply: function(target, thisArg, args) {\\n              const isIframe =\\n                args && args.length && `${args[0]}`.toLowerCase() === 'iframe'\\n              if (!isIframe) {\\n                // Everything as usual\\n                return target.apply(thisArg, args)\\n              } else {\\n                return handleIframeCreation(target, thisArg, args)\\n              }\\n            }\\n          }\\n          // All this just due to iframes with srcdoc bug\\n          utils.replaceWithProxy(\\n            document,\\n            'createElement',\\n            createElementHandler\\n          )\\n        }\\n\\n        // Let's go\\n        addIframeCreationSniffer()\\n      } catch (err) {\\n        // console.warn(err)\\n      }\\n    }\",\"_args\":[]})"},"stepId":"pw:api@17","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@37"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730793876.jpeg","width":1280,"height":720,"timestamp":804.521,"frameSwapWallTime":1732730793863.737}
{"type":"after","callId":"call@13","endTime":806.466,"afterSnapshot":"after@call@13"}
{"type":"after","callId":"call@15","endTime":806.69,"afterSnapshot":"after@call@15"}
{"type":"after","callId":"call@17","endTime":806.802,"afterSnapshot":"after@call@17"}
{"type":"after","callId":"call@19","endTime":807.924,"afterSnapshot":"after@call@19"}
{"type":"after","callId":"call@21","endTime":807.988,"afterSnapshot":"after@call@21"}
{"type":"after","callId":"call@23","endTime":808.04,"afterSnapshot":"after@call@23"}
{"type":"after","callId":"call@25","endTime":808.087,"afterSnapshot":"after@call@25"}
{"type":"after","callId":"call@27","endTime":808.13,"afterSnapshot":"after@call@27"}
{"type":"after","callId":"call@29","endTime":808.173,"afterSnapshot":"after@call@29"}
{"type":"after","callId":"call@31","endTime":808.218,"afterSnapshot":"after@call@31"}
{"type":"after","callId":"call@33","endTime":808.322,"afterSnapshot":"after@call@33"}
{"type":"after","callId":"call@35","endTime":808.382,"afterSnapshot":"after@call@35"}
{"type":"after","callId":"call@37","endTime":808.432,"afterSnapshot":"after@call@37"}
{"type":"before","callId":"call@43","startTime":813.254,"apiName":"browserContext.newCDPSession","class":"BrowserContext","method":"newCDPSession","params":{"page":{"guid":"page@57aeb351975ac179faea29c390bc1a4b"}},"stepId":"pw:api@19","beforeSnapshot":"before@call@43"}
{"type":"after","callId":"call@43","endTime":814.598,"result":{"session":"<CDPSession>"},"afterSnapshot":"after@call@43"}
{"type":"before","callId":"call@47","startTime":825.845,"apiName":"page.goto","class":"Frame","method":"goto","params":{"url":"https://localhost:5173/","waitUntil":"load"},"stepId":"pw:api@21","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@47"}
{"type":"frame-snapshot","snapshot":{"callId":"call@47","snapshotName":"before@call@47","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"about:blank","html":["HTML",{},["HEAD",{},["BASE",{"href":"about:blank"}]],["BODY"]],"viewport":{"width":1280,"height":720},"timestamp":830.681,"wallTime":1732730793900,"collectionTime":0.8000001907348633,"resourceOverrides":[],"isMainFrame":true}}
{"type":"log","callId":"call@47","time":831.479,"message":"navigating to \"https://localhost:5173/\", waiting until \"load\""}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730793905.jpeg","width":1280,"height":720,"timestamp":834.382,"frameSwapWallTime":1732730793900.442}
{"type":"console","messageType":"debug","text":"[vite] connecting...","args":[{"preview":"[vite] connecting...","value":"[vite] connecting..."}],"location":{"url":"https://localhost:5173/@vite/client","lineNumber":494,"columnNumber":8},"time":890.13,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"console","messageType":"info","text":"%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools font-weight:bold","args":[{"preview":"%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools","value":"%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools"},{"preview":"font-weight:bold","value":"font-weight:bold"}],"location":{"url":"https://localhost:5173/node_modules/.vite/deps/chunk-6BKLQ22S.js?v=1cc70104","lineNumber":21550,"columnNumber":24},"time":913.643,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794006.jpeg","width":1280,"height":720,"timestamp":934.643,"frameSwapWallTime":1732730794002.615}
{"type":"console","messageType":"debug","text":"[vite] connected.","args":[{"preview":"[vite] connected.","value":"[vite] connected."}],"location":{"url":"https://localhost:5173/@vite/client","lineNumber":613,"columnNumber":14},"time":982.356,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794062.jpeg","width":1280,"height":720,"timestamp":990.506,"frameSwapWallTime":1732730794057.7322}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794082.jpeg","width":1280,"height":720,"timestamp":1011.322,"frameSwapWallTime":1732730794078.7}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794099.jpeg","width":1280,"height":720,"timestamp":1028.212,"frameSwapWallTime":1732730794095.309}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794116.jpeg","width":1280,"height":720,"timestamp":1045.024,"frameSwapWallTime":1732730794112.747}
{"type":"console","messageType":"error","text":"Failed to load resource: the server responded with a status of 401 ()","args":[],"location":{"url":"https://localhost:7058/api/Auth/refresh","lineNumber":0,"columnNumber":0},"time":1163.169,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"console","messageType":"error","text":"Failed to load resource: the server responded with a status of 401 ()","args":[],"location":{"url":"https://localhost:7058/api/Auth/refresh","lineNumber":0,"columnNumber":0},"time":1163.439,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794236.jpeg","width":1280,"height":720,"timestamp":1164.734,"frameSwapWallTime":1732730794199.645}
{"type":"console","messageType":"error","text":"Failed to load resource: the server responded with a status of 400 ()","args":[],"location":{"url":"https://localhost:7058/api/Auth/logout","lineNumber":0,"columnNumber":0},"time":1164.908,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"console","messageType":"log","text":"AxiosError","args":[{"preview":"AxiosError"}],"location":{"url":"https://localhost:5173/src/Authentication/AuthProvider.jsx?t=1732730762105","lineNumber":73,"columnNumber":63},"time":1165.035,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794236.jpeg","width":1280,"height":720,"timestamp":1165.269,"frameSwapWallTime":1732730794203.233}
{"type":"console","messageType":"error","text":"Failed to load resource: the server responded with a status of 400 ()","args":[],"location":{"url":"https://localhost:7058/api/Auth/logout","lineNumber":0,"columnNumber":0},"time":1165.421,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"console","messageType":"log","text":"AxiosError","args":[{"preview":"AxiosError"}],"location":{"url":"https://localhost:5173/src/Authentication/AuthProvider.jsx?t=1732730762105","lineNumber":73,"columnNumber":63},"time":1165.511,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794237.jpeg","width":1280,"height":720,"timestamp":1166.2359999999999,"frameSwapWallTime":1732730794204.598}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794286.jpeg","width":1280,"height":720,"timestamp":1214.916,"frameSwapWallTime":1732730794281.459}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794338.jpeg","width":1280,"height":720,"timestamp":1267.162,"frameSwapWallTime":1732730794332.628}
{"type":"after","callId":"call@47","endTime":1286.128,"result":{"response":"<Response>"},"afterSnapshot":"after@call@47"}
{"type":"frame-snapshot","snapshot":{"callId":"call@47","snapshotName":"after@call@47","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":["HTML",{"lang":"en","data-theme":"mytheme"},["HEAD",{},["BASE",{"href":"https://localhost:5173/"}],"\n    ","\n\n    ","\n\n    ",["META",{"charset":"utf-8"}],"\n    ",["META",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],"\n    ",["TITLE",{},"Foeder"],"\n    ",["LINK",{"href":"./mainplus.css","rel":"stylesheet"}],"\n    ",["LINK",{"rel":"preconnect","href":"https://fonts.googleapis.com"}],"\n    ",["LINK",{"rel":"preconnect","href":"https://fonts.gstatic.com","crossorigin":""}],"\n    ",["LINK",{"href":"https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap","rel":"stylesheet"}],"\n    ","\n  ",["STYLE",{},"*, ::before, ::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n  --tw-contain-size:  ;\n  --tw-contain-layout:  ;\n  --tw-contain-paint:  ;\n  --tw-contain-style:  ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n  --tw-contain-size:  ;\n  --tw-contain-layout:  ;\n  --tw-contain-paint:  ;\n  --tw-contain-style:  ;\n}\n\n/*\n! tailwindcss v3.4.13 | MIT License | https://tailwindcss.com\n*/\n\n/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box;\n  /* 1 */\n  border-width: 0;\n  /* 2 */\n  border-style: solid;\n  /* 2 */\n  border-color: #e5e7eb;\n  /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n6. Use the user's configured `sans` font-variation-settings by default.\n7. Disable tap highlights on iOS\n*/\n\nhtml,\n:host {\n  line-height: 1.5;\n  /* 1 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */\n  -moz-tab-size: 4;\n  /* 3 */\n  -o-tab-size: 4;\n     tab-size: 4;\n  /* 3 */\n  font-family: ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n  /* 4 */\n  font-feature-settings: normal;\n  /* 5 */\n  font-variation-settings: normal;\n  /* 6 */\n  -webkit-tap-highlight-color: transparent;\n  /* 7 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0;\n  /* 1 */\n  line-height: inherit;\n  /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  border-top-width: 1px;\n  /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font-family by default.\n2. Use the user's configured `mono` font-feature-settings by default.\n3. Use the user's configured `mono` font-variation-settings by default.\n4. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  /* 1 */\n  font-feature-settings: normal;\n  /* 2 */\n  font-variation-settings: normal;\n  /* 3 */\n  font-size: 1em;\n  /* 4 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0;\n  /* 1 */\n  border-color: inherit;\n  /* 2 */\n  border-collapse: collapse;\n  /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-feature-settings: inherit;\n  /* 1 */\n  font-variation-settings: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  font-weight: inherit;\n  /* 1 */\n  line-height: inherit;\n  /* 1 */\n  letter-spacing: inherit;\n  /* 1 */\n  color: inherit;\n  /* 1 */\n  margin: 0;\n  /* 2 */\n  padding: 0;\n  /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\ninput:where([type='button']),\ninput:where([type='reset']),\ninput:where([type='submit']) {\n  -webkit-appearance: button;\n  /* 1 */\n  background-color: transparent;\n  /* 2 */\n  background-image: none;\n  /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nReset default styling for dialogs.\n*/\n\ndialog {\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::-moz-placeholder, textarea::-moz-placeholder {\n  opacity: 1;\n  /* 1 */\n  color: #9ca3af;\n  /* 2 */\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1;\n  /* 1 */\n  color: #9ca3af;\n  /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block;\n  /* 1 */\n  vertical-align: middle;\n  /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n\n[hidden] {\n  display: none;\n}\n\n:root,\n[data-theme] {\n  background-color: var(--fallback-b1,oklch(var(--b1)/1));\n  color: var(--fallback-bc,oklch(var(--bc)/1));\n}\n\n@supports not (color: oklch(0% 0 0)) {\n  :root {\n    color-scheme: light;\n    --fallback-p: #491eff;\n    --fallback-pc: #d4dbff;\n    --fallback-s: #ff41c7;\n    --fallback-sc: #fff9fc;\n    --fallback-a: #00cfbd;\n    --fallback-ac: #00100d;\n    --fallback-n: #2b3440;\n    --fallback-nc: #d7dde4;\n    --fallback-b1: #ffffff;\n    --fallback-b2: #e5e6e6;\n    --fallback-b3: #e5e6e6;\n    --fallback-bc: #1f2937;\n    --fallback-in: #00b3f0;\n    --fallback-inc: #000000;\n    --fallback-su: #00ca92;\n    --fallback-suc: #000000;\n    --fallback-wa: #ffc22d;\n    --fallback-wac: #000000;\n    --fallback-er: #ff6f70;\n    --fallback-erc: #000000;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :root {\n      color-scheme: dark;\n      --fallback-p: #7582ff;\n      --fallback-pc: #050617;\n      --fallback-s: #ff71cf;\n      --fallback-sc: #190211;\n      --fallback-a: #00c7b5;\n      --fallback-ac: #000e0c;\n      --fallback-n: #2a323c;\n      --fallback-nc: #a6adbb;\n      --fallback-b1: #1d232a;\n      --fallback-b2: #191e24;\n      --fallback-b3: #15191e;\n      --fallback-bc: #a6adbb;\n      --fallback-in: #00b3f0;\n      --fallback-inc: #000000;\n      --fallback-su: #00ca92;\n      --fallback-suc: #000000;\n      --fallback-wa: #ffc22d;\n      --fallback-wac: #000000;\n      --fallback-er: #ff6f70;\n      --fallback-erc: #000000;\n    }\n  }\n}\n\nhtml {\n  -webkit-tap-highlight-color: transparent;\n}\n\n* {\n  scrollbar-color: color-mix(in oklch, currentColor 35%, transparent) transparent;\n}\n\n*:hover {\n  scrollbar-color: color-mix(in oklch, currentColor 60%, transparent) transparent;\n}\n\n:root {\n  --p: 87.6743% 0.017143 88.007785;\n  --b2: 89.5736% 0.01123 116.807269;\n  --b3: 82.8315% 0.010384 116.807269;\n  --su: 64.8% 0.150 160;\n  --wa: 84.71% 0.199 83.87;\n  --er: 71.76% 0.221 22.18;\n  --bc: 19.2631% 0.002415 116.807269;\n  --pc: 17.5349% 0.003429 88.007785;\n  --sc: 15.678% 0.012953 110.778456;\n  --ac: 12.7461% 0.02461 133.073609;\n  --nc: 86.1734% 0.007308 112.772577;\n  --inc: 18.9694% 0.009922 107.309275;\n  --suc: 0% 0 0;\n  --wac: 0% 0 0;\n  --erc: 0% 0 0;\n  --rounded-box: 1rem;\n  --rounded-btn: 0.5rem;\n  --rounded-badge: 1.9rem;\n  --animation-btn: 0.25s;\n  --animation-input: .2s;\n  --btn-focus-scale: 0.95;\n  --border-btn: 1px;\n  --tab-border: 1px;\n  --tab-radius: 0.5rem;\n  --s: 78.3898% 0.064766 110.778456;\n  --a: 63.7304% 0.123048 133.073609;\n  --n: 30.8672% 0.036541 112.772577;\n  --b1: 96.3157% 0.012075 116.807269;\n  --in: 94.8471% 0.049609 107.309275;\n}\n\n.container {\n  width: 100%;\n}\n\n@media (min-width: 640px) {\n  .container {\n    max-width: 640px;\n  }\n}\n\n@media (min-width: 768px) {\n  .container {\n    max-width: 768px;\n  }\n}\n\n@media (min-width: 1024px) {\n  .container {\n    max-width: 1024px;\n  }\n}\n\n@media (min-width: 1280px) {\n  .container {\n    max-width: 1280px;\n  }\n}\n\n@media (min-width: 1536px) {\n  .container {\n    max-width: 1536px;\n  }\n}\n\n.avatar.placeholder > div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n@media (hover:hover) {\n  .label a:hover {\n    --tw-text-opacity: 1;\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n  }\n\n  .menu li > *:not(ul, .menu-title, details, .btn):active,\n.menu li > *:not(ul, .menu-title, details, .btn).active,\n.menu li > details > summary:active {\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n    --tw-text-opacity: 1;\n    color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\n  }\n\n  .table tr.hover:hover,\n  .table tr.hover:nth-child(even):hover {\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n  }\n}\n\n.btn {\n  display: inline-flex;\n  height: 3rem;\n  min-height: 3rem;\n  flex-shrink: 0;\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--rounded-btn, 0.5rem);\n  border-color: transparent;\n  border-color: oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity));\n  padding-left: 1rem;\n  padding-right: 1rem;\n  text-align: center;\n  font-size: 0.875rem;\n  line-height: 1em;\n  gap: 0.5rem;\n  font-weight: 600;\n  text-decoration-line: none;\n  transition-duration: 200ms;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  border-width: var(--border-btn, 1px);\n  transition-property: color, background-color, border-color, opacity, box-shadow, transform;\n  --tw-text-opacity: 1;\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n  outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n  background-color: oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity));\n  --tw-bg-opacity: 1;\n  --tw-border-opacity: 1;\n}\n\n.btn-disabled,\n  .btn[disabled],\n  .btn:disabled {\n  pointer-events: none;\n}\n\n:where(.btn:is(input[type=\"checkbox\"])),\n:where(.btn:is(input[type=\"radio\"])) {\n  width: auto;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n}\n\n.btn:is(input[type=\"checkbox\"]):after,\n.btn:is(input[type=\"radio\"]):after {\n  --tw-content: attr(aria-label);\n  content: var(--tw-content);\n}\n\n.card {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  border-radius: var(--rounded-box, 1rem);\n}\n\n.card:focus {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n\n.card-body {\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: column;\n  padding: var(--padding-card, 2rem);\n  gap: 0.5rem;\n}\n\n.card-body :where(p) {\n  flex-grow: 1;\n}\n\n.card figure {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.card.image-full {\n  display: grid;\n}\n\n.card.image-full:before {\n  position: relative;\n  content: \"\";\n  z-index: 10;\n  border-radius: var(--rounded-box, 1rem);\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n  opacity: 0.75;\n}\n\n.card.image-full:before,\n    .card.image-full > * {\n  grid-column-start: 1;\n  grid-row-start: 1;\n}\n\n.card.image-full > figure img {\n  height: 100%;\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n\n.card.image-full > .card-body {\n  position: relative;\n  z-index: 20;\n  --tw-text-opacity: 1;\n  color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\n}\n\n.checkbox {\n  flex-shrink: 0;\n  --chkbg: var(--fallback-bc,oklch(var(--bc)/1));\n  --chkfg: var(--fallback-b1,oklch(var(--b1)/1));\n  height: 1.5rem;\n  width: 1.5rem;\n  cursor: pointer;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border-radius: var(--rounded-btn, 0.5rem);\n  border-width: 1px;\n  border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\n  --tw-border-opacity: 0.2;\n}\n\n.collapse:not(td):not(tr):not(colgroup) {\n  visibility: visible;\n}\n\n.collapse {\n  position: relative;\n  display: grid;\n  overflow: hidden;\n  grid-template-rows: auto 0fr;\n  transition: grid-template-rows 0.2s;\n  width: 100%;\n  border-radius: var(--rounded-box, 1rem);\n}\n\n.collapse-title,\n.collapse > input[type=\"checkbox\"],\n.collapse > input[type=\"radio\"],\n.collapse-content {\n  grid-column-start: 1;\n  grid-row-start: 1;\n}\n\n.collapse > input[type=\"checkbox\"],\n.collapse > input[type=\"radio\"] {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  opacity: 0;\n}\n\n.collapse-content {\n  visibility: hidden;\n  grid-column-start: 1;\n  grid-row-start: 2;\n  min-height: 0px;\n  transition: visibility 0.2s;\n  transition: padding 0.2s ease-out,\n    background-color 0.2s ease-out;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  cursor: unset;\n}\n\n.collapse[open],\n.collapse-open,\n.collapse:focus:not(.collapse-close) {\n  grid-template-rows: auto 1fr;\n}\n\n.collapse:not(.collapse-close):has(> input[type=\"checkbox\"]:checked),\n.collapse:not(.collapse-close):has(> input[type=\"radio\"]:checked) {\n  grid-template-rows: auto 1fr;\n}\n\n.collapse[open] > .collapse-content,\n.collapse-open > .collapse-content,\n.collapse:focus:not(.collapse-close) > .collapse-content,\n.collapse:not(.collapse-close) > input[type=\"checkbox\"]:checked ~ .collapse-content,\n.collapse:not(.collapse-close) > input[type=\"radio\"]:checked ~ .collapse-content {\n  visibility: visible;\n  min-height: -moz-fit-content;\n  min-height: fit-content;\n}\n\n.dropdown {\n  position: relative;\n  display: inline-block;\n}\n\n.dropdown > *:not(summary):focus {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n\n.dropdown .dropdown-content {\n  position: absolute;\n}\n\n.dropdown:is(:not(details)) .dropdown-content {\n  visibility: hidden;\n  opacity: 0;\n  transform-origin: top;\n  --tw-scale-x: .95;\n  --tw-scale-y: .95;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 200ms;\n}\n\n.dropdown-end .dropdown-content {\n  inset-inline-end: 0px;\n}\n\n.dropdown-left .dropdown-content {\n  bottom: auto;\n  inset-inline-end: 100%;\n  top: 0px;\n  transform-origin: right;\n}\n\n.dropdown-right .dropdown-content {\n  bottom: auto;\n  inset-inline-start: 100%;\n  top: 0px;\n  transform-origin: left;\n}\n\n.dropdown-bottom .dropdown-content {\n  bottom: auto;\n  top: 100%;\n  transform-origin: top;\n}\n\n.dropdown-top .dropdown-content {\n  bottom: 100%;\n  top: auto;\n  transform-origin: bottom;\n}\n\n.dropdown-end.dropdown-right .dropdown-content {\n  bottom: 0px;\n  top: auto;\n}\n\n.dropdown-end.dropdown-left .dropdown-content {\n  bottom: 0px;\n  top: auto;\n}\n\n.dropdown.dropdown-open .dropdown-content,\n.dropdown:not(.dropdown-hover):focus .dropdown-content,\n.dropdown:focus-within .dropdown-content {\n  visibility: visible;\n  opacity: 1;\n}\n\n@media (hover: hover) {\n  .dropdown.dropdown-hover:hover .dropdown-content {\n    visibility: visible;\n    opacity: 1;\n  }\n\n  .btn:hover {\n    --tw-border-opacity: 1;\n    border-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-border-opacity)));\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-bg-opacity)));\n  }\n\n  @supports (color: color-mix(in oklab, black, black)) {\n    .btn:hover {\n      background-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity, 1)) 90%,\n            black\n          );\n      border-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity, 1)) 90%,\n            black\n          );\n    }\n  }\n\n  @supports not (color: oklch(0% 0 0)) {\n    .btn:hover {\n      background-color: var(--btn-color, var(--fallback-b2));\n      border-color: var(--btn-color, var(--fallback-b2));\n    }\n  }\n\n  .btn.glass:hover {\n    --glass-opacity: 25%;\n    --glass-border-opacity: 15%;\n  }\n\n  .btn-outline.btn-secondary:hover {\n    --tw-text-opacity: 1;\n    color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\n  }\n\n  @supports (color: color-mix(in oklab, black, black)) {\n    .btn-outline.btn-secondary:hover {\n      background-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\n      border-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\n    }\n  }\n\n  .btn-outline.btn-accent:hover {\n    --tw-text-opacity: 1;\n    color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\n  }\n\n  @supports (color: color-mix(in oklab, black, black)) {\n    .btn-outline.btn-accent:hover {\n      background-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\n      border-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\n    }\n  }\n\n  .btn-disabled:hover,\n    .btn[disabled]:hover,\n    .btn:disabled:hover {\n    --tw-border-opacity: 0;\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n    --tw-bg-opacity: 0.2;\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n    --tw-text-opacity: 0.2;\n  }\n\n  @supports (color: color-mix(in oklab, black, black)) {\n    .btn:is(input[type=\"checkbox\"]:checked):hover, .btn:is(input[type=\"radio\"]:checked):hover {\n      background-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\n      border-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\n    }\n  }\n\n  .dropdown.dropdown-hover:hover .dropdown-content {\n    --tw-scale-x: 1;\n    --tw-scale-y: 1;\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  }\n\n  :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(.active, .btn):hover, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(.active, .btn):hover {\n    cursor: pointer;\n    outline: 2px solid transparent;\n    outline-offset: 2px;\n  }\n\n  @supports (color: oklch(0% 0 0)) {\n    :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(.active, .btn):hover, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(.active, .btn):hover {\n      background-color: var(--fallback-bc,oklch(var(--bc)/0.1));\n    }\n  }\n}\n\n.dropdown:is(details) summary::-webkit-details-marker {\n  display: none;\n}\n\n.form-control {\n  display: flex;\n  flex-direction: column;\n}\n\n.label {\n  display: flex;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  align-items: center;\n  justify-content: space-between;\n  padding-left: 0.25rem;\n  padding-right: 0.25rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\n\n.input {\n  flex-shrink: 1;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  height: 3rem;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  font-size: 1rem;\n  line-height: 2;\n  line-height: 1.5rem;\n  border-radius: var(--rounded-btn, 0.5rem);\n  border-width: 1px;\n  border-color: transparent;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n}\n\n.input[type=\"number\"]::-webkit-inner-spin-button,\n.input-md[type=\"number\"]::-webkit-inner-spin-button {\n  margin-top: -1rem;\n  margin-bottom: -1rem;\n  margin-inline-end: -1rem;\n}\n\n.join {\n  display: inline-flex;\n  align-items: stretch;\n  border-radius: var(--rounded-btn, 0.5rem);\n}\n\n.join :where(.join-item) {\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: 0;\n  border-start-start-radius: 0;\n}\n\n.join .join-item:not(:first-child):not(:last-child),\n  .join *:not(:first-child):not(:last-child) .join-item {\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n  border-end-start-radius: 0;\n  border-start-start-radius: 0;\n}\n\n.join .join-item:first-child:not(:last-child),\n  .join *:first-child:not(:last-child) .join-item {\n  border-start-end-radius: 0;\n  border-end-end-radius: 0;\n}\n\n.join .dropdown .join-item:first-child:not(:last-child),\n  .join *:first-child:not(:last-child) .dropdown .join-item {\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n}\n\n.join :where(.join-item:first-child:not(:last-child)),\n  .join :where(*:first-child:not(:last-child) .join-item) {\n  border-end-start-radius: inherit;\n  border-start-start-radius: inherit;\n}\n\n.join .join-item:last-child:not(:first-child),\n  .join *:last-child:not(:first-child) .join-item {\n  border-end-start-radius: 0;\n  border-start-start-radius: 0;\n}\n\n.join :where(.join-item:last-child:not(:first-child)),\n  .join :where(*:last-child:not(:first-child) .join-item) {\n  border-start-end-radius: inherit;\n  border-end-end-radius: inherit;\n}\n\n@supports not selector(:has(*)) {\n  :where(.join *) {\n    border-radius: inherit;\n  }\n}\n\n@supports selector(:has(*)) {\n  :where(.join *:has(.join-item)) {\n    border-radius: inherit;\n  }\n}\n\n.menu {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n  padding: 0.5rem;\n}\n\n.menu :where(li ul) {\n  position: relative;\n  white-space: nowrap;\n  margin-inline-start: 1rem;\n  padding-inline-start: 0.5rem;\n}\n\n.menu :where(li:not(.menu-title) > *:not(ul, details, .menu-title, .btn)), .menu :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\n  display: grid;\n  grid-auto-flow: column;\n  align-content: flex-start;\n  align-items: center;\n  gap: 0.5rem;\n  grid-auto-columns: minmax(auto, max-content) auto max-content;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\n.menu li.disabled {\n  cursor: not-allowed;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  color: var(--fallback-bc,oklch(var(--bc)/0.3));\n}\n\n.menu :where(li > .menu-dropdown:not(.menu-dropdown-show)) {\n  display: none;\n}\n\n:where(.menu li) {\n  position: relative;\n  display: flex;\n  flex-shrink: 0;\n  flex-direction: column;\n  flex-wrap: wrap;\n  align-items: stretch;\n}\n\n:where(.menu li) .badge {\n  justify-self: end;\n}\n\n.navbar {\n  display: flex;\n  align-items: center;\n  padding: var(--navbar-padding, 0.5rem);\n  min-height: 4rem;\n  width: 100%;\n}\n\n:where(.navbar > *:not(script, style)) {\n  display: inline-flex;\n  align-items: center;\n}\n\n.navbar-start {\n  width: 50%;\n  justify-content: flex-start;\n}\n\n.navbar-center {\n  flex-shrink: 0;\n}\n\n.navbar-end {\n  width: 50%;\n  justify-content: flex-end;\n}\n\n.radio {\n  flex-shrink: 0;\n  --chkbg: var(--bc);\n  height: 1.5rem;\n  width: 1.5rem;\n  cursor: pointer;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border-radius: 9999px;\n  border-width: 1px;\n  border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\n  --tw-border-opacity: 0.2;\n}\n\n.table {\n  position: relative;\n  width: 100%;\n  border-radius: var(--rounded-box, 1rem);\n  text-align: left;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n.table :where(.table-pin-rows thead tr) {\n  position: sticky;\n  top: 0px;\n  z-index: 1;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n}\n\n.table :where(.table-pin-rows tfoot tr) {\n  position: sticky;\n  bottom: 0px;\n  z-index: 1;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n}\n\n.table :where(.table-pin-cols tr th) {\n  position: sticky;\n  left: 0px;\n  right: 0px;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n}\n\n.btm-nav > * .label {\n  font-size: 1rem;\n  line-height: 1.5rem;\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  .btn {\n    animation: button-pop var(--animation-btn, 0.25s) ease-out;\n  }\n}\n\n.btn:active:hover,\n  .btn:active:focus {\n  animation: button-pop 0s ease-out;\n  transform: scale(var(--btn-focus-scale, 0.97));\n}\n\n@supports not (color: oklch(0% 0 0)) {\n  .btn {\n    background-color: var(--btn-color, var(--fallback-b2));\n    border-color: var(--btn-color, var(--fallback-b2));\n  }\n\n  .btn-secondary {\n    --btn-color: var(--fallback-s);\n  }\n\n  .btn-accent {\n    --btn-color: var(--fallback-a);\n  }\n}\n\n@supports (color: color-mix(in oklab, black, black)) {\n  .btn-outline.btn-secondary.btn-active {\n    background-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\n    border-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\n  }\n\n  .btn-outline.btn-accent.btn-active {\n    background-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\n    border-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\n  }\n}\n\n.btn:focus-visible {\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n}\n\n@supports (color: oklch(0% 0 0)) {\n  .btn-secondary {\n    --btn-color: var(--s);\n  }\n\n  .btn-accent {\n    --btn-color: var(--a);\n  }\n}\n\n.btn-secondary {\n  --tw-text-opacity: 1;\n  color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\n  outline-color: var(--fallback-s,oklch(var(--s)/1));\n}\n\n.btn-accent {\n  --tw-text-opacity: 1;\n  color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\n  outline-color: var(--fallback-a,oklch(var(--a)/1));\n}\n\n.btn.glass {\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n  outline-color: currentColor;\n}\n\n.btn.glass.btn-active {\n  --glass-opacity: 25%;\n  --glass-border-opacity: 15%;\n}\n\n.btn-outline.btn-secondary {\n  --tw-text-opacity: 1;\n  color: var(--fallback-s,oklch(var(--s)/var(--tw-text-opacity)));\n}\n\n.btn-outline.btn-secondary.btn-active {\n  --tw-text-opacity: 1;\n  color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\n}\n\n.btn-outline.btn-accent {\n  --tw-text-opacity: 1;\n  color: var(--fallback-a,oklch(var(--a)/var(--tw-text-opacity)));\n}\n\n.btn-outline.btn-accent.btn-active {\n  --tw-text-opacity: 1;\n  color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\n}\n\n.btn.btn-disabled,\n  .btn[disabled],\n  .btn:disabled {\n  --tw-border-opacity: 0;\n  background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n  --tw-bg-opacity: 0.2;\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n  --tw-text-opacity: 0.2;\n}\n\n.btn:is(input[type=\"checkbox\"]:checked),\n.btn:is(input[type=\"radio\"]:checked) {\n  --tw-border-opacity: 1;\n  border-color: var(--fallback-p,oklch(var(--p)/var(--tw-border-opacity)));\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\n  --tw-text-opacity: 1;\n  color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\n}\n\n.btn:is(input[type=\"checkbox\"]:checked):focus-visible, .btn:is(input[type=\"radio\"]:checked):focus-visible {\n  outline-color: var(--fallback-p,oklch(var(--p)/1));\n}\n\n@keyframes button-pop {\n  0% {\n    transform: scale(var(--btn-focus-scale, 0.98));\n  }\n\n  40% {\n    transform: scale(1.02);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n}\n\n.card :where(figure:first-child) {\n  overflow: hidden;\n  border-start-start-radius: inherit;\n  border-start-end-radius: inherit;\n  border-end-start-radius: unset;\n  border-end-end-radius: unset;\n}\n\n.card :where(figure:last-child) {\n  overflow: hidden;\n  border-start-start-radius: unset;\n  border-start-end-radius: unset;\n  border-end-start-radius: inherit;\n  border-end-end-radius: inherit;\n}\n\n.card:focus-visible {\n  outline: 2px solid currentColor;\n  outline-offset: 2px;\n}\n\n.card.bordered {\n  border-width: 1px;\n  --tw-border-opacity: 1;\n  border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n}\n\n.card.compact .card-body {\n  padding: 1rem;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n.card-title {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n  font-weight: 600;\n}\n\n.card.image-full :where(figure) {\n  overflow: hidden;\n  border-radius: inherit;\n}\n\n.checkbox:focus {\n  box-shadow: none;\n}\n\n.checkbox:focus-visible {\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n  outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n}\n\n.checkbox:disabled {\n  border-width: 0px;\n  cursor: not-allowed;\n  border-color: transparent;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\n  opacity: 0.2;\n}\n\n.checkbox:checked,\n  .checkbox[aria-checked=\"true\"] {\n  background-repeat: no-repeat;\n  animation: checkmark var(--animation-input, 0.2s) ease-out;\n  background-color: var(--chkbg);\n  background-image: linear-gradient(-45deg, transparent 65%, var(--chkbg) 65.99%),\n      linear-gradient(45deg, transparent 75%, var(--chkbg) 75.99%),\n      linear-gradient(-45deg, var(--chkbg) 40%, transparent 40.99%),\n      linear-gradient(\n        45deg,\n        var(--chkbg) 30%,\n        var(--chkfg) 30.99%,\n        var(--chkfg) 40%,\n        transparent 40.99%\n      ),\n      linear-gradient(-45deg, var(--chkfg) 50%, var(--chkbg) 50.99%);\n}\n\n.checkbox:indeterminate {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\n  background-repeat: no-repeat;\n  animation: checkmark var(--animation-input, 0.2s) ease-out;\n  background-image: linear-gradient(90deg, transparent 80%, var(--chkbg) 80%),\n      linear-gradient(-90deg, transparent 80%, var(--chkbg) 80%),\n      linear-gradient(0deg, var(--chkbg) 43%, var(--chkfg) 43%, var(--chkfg) 57%, var(--chkbg) 57%);\n}\n\n@keyframes checkmark {\n  0% {\n    background-position-y: 5px;\n  }\n\n  50% {\n    background-position-y: -2px;\n  }\n\n  100% {\n    background-position-y: 0;\n  }\n}\n\ndetails.collapse {\n  width: 100%;\n}\n\ndetails.collapse summary {\n  position: relative;\n  display: block;\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n\ndetails.collapse summary::-webkit-details-marker {\n  display: none;\n}\n\n.collapse:focus-visible {\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n  outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n}\n\n.collapse:has(.collapse-title:focus-visible),\n.collapse:has(> input[type=\"checkbox\"]:focus-visible),\n.collapse:has(> input[type=\"radio\"]:focus-visible) {\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n  outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n}\n\n.collapse-arrow > .collapse-title:after {\n  position: absolute;\n  display: block;\n  height: 0.5rem;\n  width: 0.5rem;\n  --tw-translate-y: -100%;\n  --tw-rotate: 45deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 150ms;\n  transition-duration: 0.2s;\n  top: 1.9rem;\n  inset-inline-end: 1.4rem;\n  content: \"\";\n  transform-origin: 75% 75%;\n  box-shadow: 2px 2px;\n  pointer-events: none;\n}\n\n.collapse-plus > .collapse-title:after {\n  position: absolute;\n  display: block;\n  height: 0.5rem;\n  width: 0.5rem;\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 300ms;\n  top: 0.9rem;\n  inset-inline-end: 1.4rem;\n  content: \"+\";\n  pointer-events: none;\n}\n\n.collapse:not(.collapse-open):not(.collapse-close) > input[type=\"checkbox\"],\n.collapse:not(.collapse-open):not(.collapse-close) > input[type=\"radio\"]:not(:checked),\n.collapse:not(.collapse-open):not(.collapse-close) > .collapse-title {\n  cursor: pointer;\n}\n\n.collapse:focus:not(.collapse-open):not(.collapse-close):not(.collapse[open]) > .collapse-title {\n  cursor: unset;\n}\n\n.collapse-title {\n  position: relative;\n}\n\n:where(.collapse > input[type=\"checkbox\"]),\n:where(.collapse > input[type=\"radio\"]) {\n  z-index: 1;\n}\n\n.collapse-title,\n:where(.collapse > input[type=\"checkbox\"]),\n:where(.collapse > input[type=\"radio\"]) {\n  width: 100%;\n  padding: 1rem;\n  padding-inline-end: 3rem;\n  min-height: 3.75rem;\n  transition: background-color 0.2s ease-out;\n}\n\n.collapse[open] > :where(.collapse-content),\n.collapse-open > :where(.collapse-content),\n.collapse:focus:not(.collapse-close) > :where(.collapse-content),\n.collapse:not(.collapse-close) > :where(input[type=\"checkbox\"]:checked ~ .collapse-content),\n.collapse:not(.collapse-close) > :where(input[type=\"radio\"]:checked ~ .collapse-content) {\n  padding-bottom: 1rem;\n  transition: padding 0.2s ease-out,\n    background-color 0.2s ease-out;\n}\n\n.collapse[open].collapse-arrow > .collapse-title:after,\n.collapse-open.collapse-arrow > .collapse-title:after,\n.collapse-arrow:focus:not(.collapse-close) > .collapse-title:after,\n.collapse-arrow:not(.collapse-close) > input[type=\"checkbox\"]:checked ~ .collapse-title:after,\n.collapse-arrow:not(.collapse-close) > input[type=\"radio\"]:checked ~ .collapse-title:after {\n  --tw-translate-y: -50%;\n  --tw-rotate: 225deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n\n.collapse[open].collapse-plus > .collapse-title:after,\n.collapse-open.collapse-plus > .collapse-title:after,\n.collapse-plus:focus:not(.collapse-close) > .collapse-title:after,\n.collapse-plus:not(.collapse-close) > input[type=\"checkbox\"]:checked ~ .collapse-title:after,\n.collapse-plus:not(.collapse-close) > input[type=\"radio\"]:checked ~ .collapse-title:after {\n  content: \"−\";\n}\n\n.dropdown.dropdown-open .dropdown-content,\n.dropdown:focus .dropdown-content,\n.dropdown:focus-within .dropdown-content {\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n\n.label-text {\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n  --tw-text-opacity: 1;\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n}\n\n.input input {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\n  background-color: transparent;\n}\n\n.input input:focus {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n\n.input[list]::-webkit-calendar-picker-indicator {\n  line-height: 1em;\n}\n\n.input-bordered {\n  border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\n}\n\n.input:focus,\n  .input:focus-within {\n  box-shadow: none;\n  border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n  outline-color: var(--fallback-bc,oklch(var(--bc)/0.2));\n}\n\n.input:has(> input[disabled]),\n  .input-disabled,\n  .input:disabled,\n  .input[disabled] {\n  cursor: not-allowed;\n  --tw-border-opacity: 1;\n  border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n  color: var(--fallback-bc,oklch(var(--bc)/0.4));\n}\n\n.input:has(> input[disabled])::-moz-placeholder, .input-disabled::-moz-placeholder, .input:disabled::-moz-placeholder, .input[disabled]::-moz-placeholder {\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n  --tw-placeholder-opacity: 0.2;\n}\n\n.input:has(> input[disabled])::placeholder,\n  .input-disabled::placeholder,\n  .input:disabled::placeholder,\n  .input[disabled]::placeholder {\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n  --tw-placeholder-opacity: 0.2;\n}\n\n.input:has(> input[disabled]) > input[disabled] {\n  cursor: not-allowed;\n}\n\n.input::-webkit-date-and-time-value {\n  text-align: inherit;\n}\n\n.join > :where(*:not(:first-child)) {\n  margin-top: 0px;\n  margin-bottom: 0px;\n  margin-inline-start: -1px;\n}\n\n.join > :where(*:not(:first-child)):is(.btn) {\n  margin-inline-start: calc(var(--border-btn) * -1);\n}\n\n:where(.menu li:empty) {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\n  opacity: 0.1;\n  margin: 0.5rem 1rem;\n  height: 1px;\n}\n\n.menu :where(li ul):before {\n  position: absolute;\n  bottom: 0.75rem;\n  inset-inline-start: 0px;\n  top: 0.75rem;\n  width: 1px;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\n  opacity: 0.1;\n  content: \"\";\n}\n\n.menu :where(li:not(.menu-title) > *:not(ul, details, .menu-title, .btn)),\n.menu :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\n  border-radius: var(--rounded-btn, 0.5rem);\n  padding-left: 1rem;\n  padding-right: 1rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n  text-align: start;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  transition-duration: 200ms;\n  text-wrap: balance;\n}\n\n:where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(summary, .active, .btn).focus, :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(summary, .active, .btn):focus, :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):is(summary):not(.active, .btn):focus-visible, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(summary, .active, .btn).focus, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(summary, .active, .btn):focus, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):is(summary):not(.active, .btn):focus-visible {\n  cursor: pointer;\n  background-color: var(--fallback-bc,oklch(var(--bc)/0.1));\n  --tw-text-opacity: 1;\n  color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n\n.menu li > *:not(ul, .menu-title, details, .btn):active,\n.menu li > *:not(ul, .menu-title, details, .btn).active,\n.menu li > details > summary:active {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n  --tw-text-opacity: 1;\n  color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\n}\n\n.menu :where(li > details > summary)::-webkit-details-marker {\n  display: none;\n}\n\n.menu :where(li > details > summary):after,\n.menu :where(li > .menu-dropdown-toggle):after {\n  justify-self: end;\n  display: block;\n  margin-top: -0.5rem;\n  height: 0.5rem;\n  width: 0.5rem;\n  transform: rotate(45deg);\n  transition-property: transform, margin-top;\n  transition-duration: 0.3s;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  content: \"\";\n  transform-origin: 75% 75%;\n  box-shadow: 2px 2px;\n  pointer-events: none;\n}\n\n.menu :where(li > details[open] > summary):after,\n.menu :where(li > .menu-dropdown-toggle.menu-dropdown-show):after {\n  transform: rotate(225deg);\n  margin-top: 0;\n}\n\n.mockup-browser .mockup-browser-toolbar .input {\n  position: relative;\n  margin-left: auto;\n  margin-right: auto;\n  display: block;\n  height: 1.75rem;\n  width: 24rem;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n  padding-left: 2rem;\n  direction: ltr;\n}\n\n.mockup-browser .mockup-browser-toolbar .input:before {\n  content: \"\";\n  position: absolute;\n  left: 0.5rem;\n  top: 50%;\n  aspect-ratio: 1 / 1;\n  height: 0.75rem;\n  --tw-translate-y: -50%;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  border-radius: 9999px;\n  border-width: 2px;\n  border-color: currentColor;\n  opacity: 0.6;\n}\n\n.mockup-browser .mockup-browser-toolbar .input:after {\n  content: \"\";\n  position: absolute;\n  left: 1.25rem;\n  top: 50%;\n  height: 0.5rem;\n  --tw-translate-y: 25%;\n  --tw-rotate: -45deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  border-radius: 9999px;\n  border-width: 1px;\n  border-color: currentColor;\n  opacity: 0.6;\n}\n\n@keyframes modal-pop {\n  0% {\n    opacity: 0;\n  }\n}\n\n@keyframes progress-loading {\n  50% {\n    background-position-x: -115%;\n  }\n}\n\n.radio:focus {\n  box-shadow: none;\n}\n\n.radio:focus-visible {\n  outline-style: solid;\n  outline-width: 2px;\n  outline-offset: 2px;\n  outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n}\n\n.radio:checked,\n  .radio[aria-checked=\"true\"] {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\n  background-image: none;\n  animation: radiomark var(--animation-input, 0.2s) ease-out;\n  box-shadow: 0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset;\n}\n\n.radio:disabled {\n  cursor: not-allowed;\n  opacity: 0.2;\n}\n\n@keyframes radiomark {\n  0% {\n    box-shadow: 0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset;\n  }\n\n  50% {\n    box-shadow: 0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset;\n  }\n\n  100% {\n    box-shadow: 0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset;\n  }\n}\n\n@keyframes rating-pop {\n  0% {\n    transform: translateY(-0.125em);\n  }\n\n  40% {\n    transform: translateY(-0.125em);\n  }\n\n  100% {\n    transform: translateY(0);\n  }\n}\n\n@keyframes skeleton {\n  from {\n    background-position: 150%;\n  }\n\n  to {\n    background-position: -50%;\n  }\n}\n\n.table:where([dir=\"rtl\"], [dir=\"rtl\"] *) {\n  text-align: right;\n}\n\n.table :where(th, td) {\n  padding-left: 1rem;\n  padding-right: 1rem;\n  padding-top: 0.75rem;\n  padding-bottom: 0.75rem;\n  vertical-align: middle;\n}\n\n.table tr.active,\n  .table tr.active:nth-child(even),\n  .table-zebra tbody tr:nth-child(even) {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n}\n\n.table :where(thead tr, tbody tr:not(:last-child), tbody tr:first-child:last-child) {\n  border-bottom-width: 1px;\n  --tw-border-opacity: 1;\n  border-bottom-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n}\n\n.table :where(thead, tfoot) {\n  white-space: nowrap;\n  font-size: 0.75rem;\n  line-height: 1rem;\n  font-weight: 700;\n  color: var(--fallback-bc,oklch(var(--bc)/0.6));\n}\n\n.table :where(tfoot) {\n  border-top-width: 1px;\n  --tw-border-opacity: 1;\n  border-top-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n}\n\n@keyframes toast-pop {\n  0% {\n    transform: scale(0.9);\n    opacity: 0;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n\n.btn-xs {\n  height: 1.5rem;\n  min-height: 1.5rem;\n  padding-left: 0.5rem;\n  padding-right: 0.5rem;\n  font-size: 0.75rem;\n}\n\n.btn-sm {\n  height: 2rem;\n  min-height: 2rem;\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n  font-size: 0.875rem;\n}\n\n.btn-block {\n  width: 100%;\n}\n\n.btn-square:where(.btn-xs) {\n  height: 1.5rem;\n  width: 1.5rem;\n  padding: 0px;\n}\n\n.btn-square:where(.btn-sm) {\n  height: 2rem;\n  width: 2rem;\n  padding: 0px;\n}\n\n.btn-circle:where(.btn-xs) {\n  height: 1.5rem;\n  width: 1.5rem;\n  border-radius: 9999px;\n  padding: 0px;\n}\n\n.btn-circle:where(.btn-sm) {\n  height: 2rem;\n  width: 2rem;\n  border-radius: 9999px;\n  padding: 0px;\n}\n\n.join.join-vertical {\n  flex-direction: column;\n}\n\n.join.join-vertical .join-item:first-child:not(:last-child),\n  .join.join-vertical *:first-child:not(:last-child) .join-item {\n  border-end-start-radius: 0;\n  border-end-end-radius: 0;\n  border-start-start-radius: inherit;\n  border-start-end-radius: inherit;\n}\n\n.join.join-vertical .join-item:last-child:not(:first-child),\n  .join.join-vertical *:last-child:not(:first-child) .join-item {\n  border-start-start-radius: 0;\n  border-start-end-radius: 0;\n  border-end-start-radius: inherit;\n  border-end-end-radius: inherit;\n}\n\n.join.join-horizontal {\n  flex-direction: row;\n}\n\n.join.join-horizontal .join-item:first-child:not(:last-child),\n  .join.join-horizontal *:first-child:not(:last-child) .join-item {\n  border-end-end-radius: 0;\n  border-start-end-radius: 0;\n  border-end-start-radius: inherit;\n  border-start-start-radius: inherit;\n}\n\n.join.join-horizontal .join-item:last-child:not(:first-child),\n  .join.join-horizontal *:last-child:not(:first-child) .join-item {\n  border-end-start-radius: 0;\n  border-start-start-radius: 0;\n  border-end-end-radius: inherit;\n  border-start-end-radius: inherit;\n}\n\n.menu-horizontal {\n  display: inline-flex;\n  flex-direction: row;\n}\n\n.menu-horizontal > li:not(.menu-title) > details > ul {\n  position: absolute;\n}\n\n.card-compact .card-body {\n  padding: 1rem;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n.card-compact .card-title {\n  margin-bottom: 0.25rem;\n}\n\n.card-normal .card-body {\n  padding: var(--padding-card, 2rem);\n  font-size: 1rem;\n  line-height: 1.5rem;\n}\n\n.card-normal .card-title {\n  margin-bottom: 0.75rem;\n}\n\n.join.join-vertical > :where(*:not(:first-child)) {\n  margin-left: 0px;\n  margin-right: 0px;\n  margin-top: -1px;\n}\n\n.join.join-vertical > :where(*:not(:first-child)):is(.btn) {\n  margin-top: calc(var(--border-btn) * -1);\n}\n\n.join.join-horizontal > :where(*:not(:first-child)) {\n  margin-top: 0px;\n  margin-bottom: 0px;\n  margin-inline-start: -1px;\n}\n\n.join.join-horizontal > :where(*:not(:first-child)):is(.btn) {\n  margin-inline-start: calc(var(--border-btn) * -1);\n  margin-top: 0px;\n}\n\n.menu-horizontal > li:not(.menu-title) > details > ul {\n  margin-inline-start: 0px;\n  margin-top: 1rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n  padding-inline-end: 0.5rem;\n}\n\n.menu-horizontal > li > details > ul:before {\n  content: none;\n}\n\n:where(.menu-horizontal > li:not(.menu-title) > details > ul) {\n  border-radius: var(--rounded-box, 1rem);\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.menu-sm :where(li:not(.menu-title) > *:not(ul, details, .menu-title)), .menu-sm :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\n  border-radius: var(--rounded-btn, 0.5rem);\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n.menu-sm .menu-title {\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\n\n.collapse {\n  visibility: collapse;\n}\n\n.absolute {\n  position: absolute;\n}\n\n.relative {\n  position: relative;\n}\n\n.z-\\[1\\] {\n  z-index: 1;\n}\n\n.z-\\[2\\] {\n  z-index: 2;\n}\n\n.col-span-12 {\n  grid-column: span 12 / span 12;\n}\n\n.col-span-6 {\n  grid-column: span 6 / span 6;\n}\n\n.mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.my-8 {\n  margin-top: 2rem;\n  margin-bottom: 2rem;\n}\n\n.mx-4 {\n  margin-left: 1rem;\n  margin-right: 1rem;\n}\n\n.-ml-6 {\n  margin-left: -1.5rem;\n}\n\n.mb-8 {\n  margin-bottom: 2rem;\n}\n\n.mt-3 {\n  margin-top: 0.75rem;\n}\n\n.mt-4 {\n  margin-top: 1rem;\n}\n\n.mt-6 {\n  margin-top: 1.5rem;\n}\n\n.mt-8 {\n  margin-top: 2rem;\n}\n\n.block {\n  display: block;\n}\n\n.flex {\n  display: flex;\n}\n\n.table {\n  display: table;\n}\n\n.grid {\n  display: grid;\n}\n\n.hidden {\n  display: none;\n}\n\n.h-12 {\n  height: 3rem;\n}\n\n.h-14 {\n  height: 3.5rem;\n}\n\n.h-5 {\n  height: 1.25rem;\n}\n\n.h-\\[100vh\\] {\n  height: 100vh;\n}\n\n.h-full {\n  height: 100%;\n}\n\n.min-h-0 {\n  min-height: 0px;\n}\n\n.w-28 {\n  width: 7rem;\n}\n\n.w-5 {\n  width: 1.25rem;\n}\n\n.w-52 {\n  width: 13rem;\n}\n\n.w-\\[calc\\(100\\%\\+3rem\\)\\] {\n  width: calc(100% + 3rem);\n}\n\n.w-full {\n  width: 100%;\n}\n\n.w-96 {\n  width: 24rem;\n}\n\n.w-60 {\n  width: 15rem;\n}\n\n.w-64 {\n  width: 16rem;\n}\n\n.w-72 {\n  width: 18rem;\n}\n\n.max-w-3xl {\n  max-width: 48rem;\n}\n\n.max-w-xs {\n  max-width: 20rem;\n}\n\n.flex-none {\n  flex: none;\n}\n\n.flex-1 {\n  flex: 1 1 0%;\n}\n\n.grid-cols-12 {\n  grid-template-columns: repeat(12, minmax(0, 1fr));\n}\n\n.flex-col {\n  flex-direction: column;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.items-start {\n  align-items: flex-start;\n}\n\n.items-center {\n  align-items: center;\n}\n\n.justify-center {\n  justify-content: center;\n}\n\n.gap-5 {\n  gap: 1.25rem;\n}\n\n.gap-1 {\n  gap: 0.25rem;\n}\n\n.gap-y-10 {\n  row-gap: 2.5rem;\n}\n\n.overflow-hidden {\n  overflow: hidden;\n}\n\n.whitespace-pre-wrap {\n  white-space: pre-wrap;\n}\n\n.rounded-box {\n  border-radius: var(--rounded-box, 1rem);\n}\n\n.bg-base-100 {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n}\n\n.bg-neutral {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n}\n\n.bg-secondary {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-s,oklch(var(--s)/var(--tw-bg-opacity)));\n}\n\n.bg-base-200 {\n  --tw-bg-opacity: 1;\n  background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n}\n\n.p-2 {\n  padding: 0.5rem;\n}\n\n.p-6 {\n  padding: 1.5rem;\n}\n\n.px-4 {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\n\n.px-6 {\n  padding-left: 1.5rem;\n  padding-right: 1.5rem;\n}\n\n.py-8 {\n  padding-top: 2rem;\n  padding-bottom: 2rem;\n}\n\n.pb-6 {\n  padding-bottom: 1.5rem;\n}\n\n.pl-6 {\n  padding-left: 1.5rem;\n}\n\n.pr-6 {\n  padding-right: 1.5rem;\n}\n\n.pt-4 {\n  padding-top: 1rem;\n}\n\n.pt-8 {\n  padding-top: 2rem;\n}\n\n.text-center {\n  text-align: center;\n}\n\n.align-middle {\n  vertical-align: middle;\n}\n\n.text-2xl {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n\n.text-4xl {\n  font-size: 2.25rem;\n  line-height: 2.5rem;\n}\n\n.text-5xl {\n  font-size: 3rem;\n  line-height: 1;\n}\n\n.text-lg {\n  font-size: 1.125rem;\n  line-height: 1.75rem;\n}\n\n.text-sm {\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\n\n.text-xl {\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n}\n\n.font-bold {\n  font-weight: 700;\n}\n\n.font-medium {\n  font-weight: 500;\n}\n\n.text-base-100 {\n  --tw-text-opacity: 1;\n  color: var(--fallback-b1,oklch(var(--b1)/var(--tw-text-opacity)));\n}\n\n.text-black {\n  --tw-text-opacity: 1;\n  color: rgb(0 0 0 / var(--tw-text-opacity));\n}\n\n.text-neutral-content {\n  --tw-text-opacity: 1;\n  color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\n}\n\n.text-secondary-content {\n  --tw-text-opacity: 1;\n  color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\n}\n\n.text-white {\n  --tw-text-opacity: 1;\n  color: rgb(255 255 255 / var(--tw-text-opacity));\n}\n\n.shadow {\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.shadow-xl {\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\nbody, html{\n  margin: 0;\n  padding: 0;\n  height: 100%;\n}\n\n.foederFont{\n  font-family: \"Abril Fatface\", serif;\n  font-weight: 400;\n  font-style: normal;\n}\n\n.inter-mainFont {\n  font-family: \"Inter\", sans-serif;\n  font-optical-sizing: auto;\n  font-style: normal;\n}\n\n#root {\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.full-screen-container{\n  flex: 1;\n  background: rgb(186,190,175);\n  background: radial-gradient(circle, rgba(186,190,175,1) 0%, rgba(233,234,226,1) 100%);\n  height: 100%;\n  overflow: auto;\n}\n\n.apples-img {\n  bottom: 15%;\n  right: -25%;\n  /* Align to the right edge */\n  width: auto;\n  height: 100%;\n  z-index: 0;\n  /* Place behind text */\n}\n\n@media (min-width: 768px) {\n  .md\\:input-lg[type=\"number\"]::-webkit-inner-spin-button {\n    margin-top: -1.5rem;\n    margin-bottom: -1.5rem;\n    margin-inline-end: -1.5rem;\n  }\n\n  .md\\:input-lg {\n    height: 4rem;\n    padding-left: 1.5rem;\n    padding-right: 1.5rem;\n    font-size: 1.125rem;\n    line-height: 1.75rem;\n    line-height: 2;\n  }\n\n  .md\\:col-span-3 {\n    grid-column: span 3 / span 3;\n  }\n\n  .md\\:col-span-6 {\n    grid-column: span 6 / span 6;\n  }\n\n  .md\\:mr-4 {\n    margin-right: 1rem;\n  }\n\n  .md\\:flex {\n    display: flex;\n  }\n\n  .md\\:w-52 {\n    width: 13rem;\n  }\n\n  .md\\:w-96 {\n    width: 24rem;\n  }\n\n  .md\\:w-72 {\n    width: 18rem;\n  }\n\n  .md\\:max-w-3xl {\n    max-width: 48rem;\n  }\n\n  .md\\:px-8 {\n    padding-left: 2rem;\n    padding-right: 2rem;\n  }\n\n  .md\\:px-20 {\n    padding-left: 5rem;\n    padding-right: 5rem;\n  }\n\n  .md\\:text-4xl {\n    font-size: 2.25rem;\n    line-height: 2.5rem;\n  }\n\n  .md\\:text-lg {\n    font-size: 1.125rem;\n    line-height: 1.75rem;\n  }\n\n  .md\\:text-xl {\n    font-size: 1.25rem;\n    line-height: 1.75rem;\n  }\n}\n\n@media (min-width: 1024px) {\n  .lg\\:mt-6 {\n    margin-top: 1.5rem;\n  }\n\n  .lg\\:flex {\n    display: flex;\n  }\n\n  .lg\\:hidden {\n    display: none;\n  }\n\n  .lg\\:max-w-4xl {\n    max-width: 56rem;\n  }\n\n  .lg\\:border {\n    border-width: 1px;\n  }\n\n  .lg\\:border-gray-300 {\n    --tw-border-opacity: 1;\n    border-color: rgb(209 213 219 / var(--tw-border-opacity));\n  }\n\n  .lg\\:text-xl {\n    font-size: 1.25rem;\n    line-height: 1.75rem;\n  }\n}\n\n@media (min-width: 1280px) {\n  .xl\\:max-w-4xl {\n    max-width: 56rem;\n  }\n\n  .xl\\:px-96 {\n    padding-left: 24rem;\n    padding-right: 24rem;\n  }\n\n  .xl\\:px-72 {\n    padding-left: 18rem;\n    padding-right: 18rem;\n  }\n}\n\n@media (min-width: 1536px) {\n  .\\32xl\\:max-w-7xl {\n    max-width: 80rem;\n  }\n}\r\n\r\n"],["STYLE",{},".qJTHM{-webkit-user-select:none;color:#202124;direction:ltr;-webkit-touch-callout:none;font-family:\"Roboto-Regular\",arial,sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;margin:0;overflow:hidden;-webkit-text-size-adjust:100%}.ynRLnc{left:-9999px;position:absolute;top:-9999px}.L6cTce{display:none}.bltWBb{word-break:break-all}.hSRGPd{color:#1a73e8;cursor:pointer;font-weight:500;text-decoration:none}.Bz112c-W3lGp{height:16px;width:16px}.Bz112c-E3DyYd{height:20px;width:20px}.Bz112c-r9oPif{height:24px;width:24px}.Bz112c-uaxL4e{-webkit-border-radius:10px;border-radius:10px}.LgbsSe-Bz112c{display:block}.S9gUrf-YoZ4jf,.S9gUrf-YoZ4jf *{border:none;margin:0;padding:0}.fFW7wc-ibnC6b>.aZ2wEe>div{border-color:#4285f4}.P1ekSe-ZMv3u>div:nth-child(1){background-color:#1a73e8!important}.P1ekSe-ZMv3u>div:nth-child(2),.P1ekSe-ZMv3u>div:nth-child(3){background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.haAclf{display:inline-block}.nsm7Bb-HzV7m-LgbsSe{-webkit-border-radius:4px;border-radius:4px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:background-color .218s,border-color .218s;transition:background-color .218s,border-color .218s;-webkit-user-select:none;-webkit-appearance:none;background-color:#fff;background-image:none;border:1px solid #dadce0;color:#3c4043;cursor:pointer;font-family:\"Google Sans\",arial,sans-serif;font-size:14px;height:40px;letter-spacing:0.25px;outline:none;overflow:hidden;padding:0 12px;position:relative;text-align:center;vertical-align:middle;white-space:nowrap;width:auto}@media screen and (-ms-high-contrast:active){.nsm7Bb-HzV7m-LgbsSe{border:2px solid windowText;color:windowText}}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe{font-size:14px;height:32px;letter-spacing:0.25px;padding:0 10px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe{font-size:11px;height:20px;letter-spacing:0.3px;padding:0 8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe{padding:0;width:40px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe{width:32px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe{width:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK{-webkit-border-radius:20px;border-radius:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.pSzOP-SxQuSe{-webkit-border-radius:16px;border-radius:16px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.purZT-SxQuSe{-webkit-border-radius:10px;border-radius:10px}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc{border:none;color:#fff}.nsm7Bb-HzV7m-LgbsSe.MFS4be-v3pZbf-Ia7Qfc{background-color:#1a73e8}.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{background-color:#202124;color:#e8eaed}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:18px;margin-right:8px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:14px;min-width:14px;width:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:10px;min-width:10px;width:10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin-left:8px;margin-right:-4px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:10px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:4px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;display:-webkit-box;display:-webkit-flex;display:flex;justify-content:center;-webkit-align-items:center;align-items:center;background-color:#fff;height:36px;margin-left:-10px;margin-right:12px;min-width:36px;width:36px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c,.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:28px;margin-left:-8px;margin-right:10px;min-width:28px;width:28px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:16px;margin-left:-6px;margin-right:8px;min-width:16px;width:16px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:3px;border-radius:3px;margin-left:2px;margin-right:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:14px;border-radius:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:8px;border-radius:8px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;-webkit-flex-direction:row;flex-direction:row;justify-content:space-between;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;height:100%;position:relative;width:100%}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX{justify-content:center}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:1;flex-grow:1;font-family:\"Google Sans\",arial,sans-serif;font-weight:500;overflow:hidden;text-overflow:ellipsis;vertical-align:top}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-weight:300}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:0;flex-grow:0}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-MJoBVe{-webkit-transition:background-color .218s;transition:background-color .218s;bottom:0;left:0;position:absolute;right:0;top:0}.nsm7Bb-HzV7m-LgbsSe:hover,.nsm7Bb-HzV7m-LgbsSe:focus{-webkit-box-shadow:none;box-shadow:none;border-color:#d2e3fc;outline:none}.nsm7Bb-HzV7m-LgbsSe:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.04)}.nsm7Bb-HzV7m-LgbsSe:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.1)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.24)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.32)}.nsm7Bb-HzV7m-LgbsSe .n1UuX-DkfjY{-webkit-border-radius:50%;border-radius:50%;display:-webkit-box;display:-webkit-flex;display:flex;height:20px;margin-left:-4px;margin-right:8px;min-width:20px;width:20px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-family:\"Roboto\";font-size:12px;text-align:left}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .ssJRIf,.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .fmcmS{overflow:hidden;text-overflow:ellipsis}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;color:#5f6368;fill:#5f6368;font-size:11px;font-weight:400}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#e8eaed;fill:#e8eaed}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .Bz112c{height:18px;margin:-3px -3px -3px 2px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:0;border-top-left-radius:0;-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;margin-left:12px;margin-right:-10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.L5Fo6c-sM5MNb{border:0;display:block;left:0;position:relative;top:0}.L5Fo6c-bF1uUb{-webkit-border-radius:4px;border-radius:4px;bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.L5Fo6c-bF1uUb:focus{border:none;outline:none}sentinel{}"],["LINK",{"id":"googleidentityservice","type":"text/css","media":"all","href":"https://accounts.google.com/gsi/style","rel":"stylesheet"}]],"\n  ",["BODY",{},"\n    ",["DIV",{"id":"root"},["DIV",{"class":"h-[100vh] overflow-hidden"},["DIV",{"class":"navbar bg-base0100 min-h-0 h-12"},["DIV",{"class":"navbar-start md:mr-4 "},["DIV",{"class":"dropdown"},["DIV",{"tabindex":"0","role":"button","class":"btn btn-accent btn-sm lg:hidden"},["svg",{"xmlns":"http://www.w3.org/2000/svg","class":"h-5 w-5","fill":"none","viewBox":"0 0 24 24","stroke":"#DBD6CA"},["path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2","d":"M4 6h16M4 12h8m-8 6h16"}]]],["UL",{"tabindex":"0","class":"menu menu-sm dropdown-content bg-neutral text-neutral-content rounded-box z-[2] mt-3 w-52 p-2 shadow"},["LI"],["LI",{},["A",{},"Parent"],["UL",{"class":"p-2"},["LI",{},["A",{},"Submenu 1"]],["LI",{},["A",{},"Submenu 2"]]]],["LI",{},["A",{},"Item 3"]]]],["A",{"class":"hidden lg:flex btn btn-sm btn-accent text-base-100 text-lg foederFont","href":"/"},"Foeder"]],["DIV",{"class":"navbar-center"},["A",{"class":"text-sm lg:hidden btn btn-accent btn-xs text-base-100 foederFont lg:text-xl","href":"/"},"Foeder"],["UL",{"class":"menu menu-horizontal hidden lg:flex"},["LI",{"class":"text-black inter-mainFont font-medium text-lg"}],["LI",{"class":"text-black inter-mainFont font-medium text-lg"},["A",{"href":"/household"},"Household"]]]],["DIV",{"class":"navbar-end"}]],["DIV",{"class":"w-full full-screen-container"},["DIV",{"class":"relative overflow-hidden h-[100vh]"},["DIV",{"class":" mx-auto grid grid-cols-12 gap-5 px-6 md:px-8"},["DIV",{"class":"col-span-12 md:col-span-3 z-[1] "},["P",{"class":"inter-mainFont font-bold text-5xl pt-8"},"Recipe and pantry stock-keeping"],["P",{"class":"inter-mainFont text-xl pt-8"},"It’s easy to get started with Foeder. Just create an account by signing up with your google account."],["DIV",{"class":"py-8"},["DIV",{"id":"signInContainer","class":"z-[1]"},["DIV",{"id":"signInDiv"},["DIV",{"class":"S9gUrf-YoZ4jf","style":"position: relative;"},["DIV",{},["DIV",{"tabindex":"0","role":"button","aria-labelledby":"button-label","class":"nsm7Bb-HzV7m-LgbsSe  hJDwNd-SxQuSe MFS4be-JaPV2b-Ia7Qfc MFS4be-Ia7Qfc JGcpL-RbRzK"},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-MJoBVe"}],["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb "},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf"},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-Bz112c"},["svg",{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 48 48","class":"LgbsSe-Bz112c"},["g",{},["path",{"fill":"#EA4335","d":"M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"}],["path",{"fill":"#4285F4","d":"M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"}],["path",{"fill":"#FBBC05","d":"M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"}],["path",{"fill":"#34A853","d":"M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"}],["path",{"fill":"none","d":"M0 0h48v48H0z"}]]]]],["SPAN",{"class":"nsm7Bb-HzV7m-LgbsSe-BPrWId"},"Inloggen"],["SPAN",{"class":"L6cTce","id":"button-label"},"Inloggen met Google"]]]],["IFRAME",{"src":"/snapshot/frame@95e7e8d29a071e743298104c5fcd78ce","allow":"identity-credentials-get","id":"gsi_794130_195463","title":"Knop Inloggen met Google","style":"display: block; position: relative; top: 0px; left: 0px; height: 0px; width: 0px; border: 0px;"}]]]]]]],["IMG",{"__playwright_current_src__":"https://localhost:5173/src/img/apples.png","class":"hidden md:flex absolute apples-img","src":"/src/img/apples.png","alt":"Apples"}]]]]],"\n    ","\n  \n\n"]],"viewport":{"width":1280,"height":720},"timestamp":1294.2649999999999,"wallTime":1732730794363,"collectionTime":1.2999999523162842,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@47","snapshotName":"after@call@47","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":["HTML",{"lang":"nl"},["HEAD",{},["BASE",{"href":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ"}],["TITLE",{},"Sign In - Google Accounts"],["META",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["META",{"name":"referrer","content":"no-referrer"}],["STYLE",{},"@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(//fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxP.ttf)format('truetype');}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;src:url(//fonts.gstatic.com/s/roboto/v18/KFOlCnqEu92Fr1MmEU9fBBc9.ttf)format('truetype');}@font-face{font-family:'Google Sans';font-style:normal;font-weight:400;src:url(//fonts.gstatic.com/s/googlesans/v58/4Ua_rENHsxJlGDuGo1OIlJfC6l_24rlCK1Yo_Iqcsih3SAyH6cAwhX9RFD48TE63OOYKtrwEIJllpyw.ttf)format('truetype');}@font-face{font-family:'Google Sans';font-style:normal;font-weight:500;src:url(//fonts.gstatic.com/s/googlesans/v58/4Ua_rENHsxJlGDuGo1OIlJfC6l_24rlCK1Yo_Iqcsih3SAyH6cAwhX9RFD48TE63OOYKtrw2IJllpyw.ttf)format('truetype');}"],["STYLE",{},".qJTHM{-webkit-user-select:none;color:#202124;direction:ltr;-webkit-touch-callout:none;font-family:\"Roboto-Regular\",arial,sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;margin:0;overflow:hidden;-webkit-text-size-adjust:100%}.ynRLnc{left:-9999px;position:absolute;top:-9999px}.L6cTce{display:none}.bltWBb{word-break:break-all}.hSRGPd{color:#1a73e8;cursor:pointer;font-weight:500;text-decoration:none}.Bz112c-W3lGp{height:16px;width:16px}.Bz112c-E3DyYd{height:20px;width:20px}.Bz112c-r9oPif{height:24px;width:24px}.Bz112c-uaxL4e{-webkit-border-radius:10px;border-radius:10px}.LgbsSe-Bz112c{display:block}.S9gUrf-YoZ4jf,.S9gUrf-YoZ4jf *{border:none;margin:0;padding:0}.fFW7wc-ibnC6b>.aZ2wEe>div{border-color:#4285f4}.P1ekSe-ZMv3u>div:nth-child(1){background-color:#1a73e8!important}.P1ekSe-ZMv3u>div:nth-child(2),.P1ekSe-ZMv3u>div:nth-child(3){background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.haAclf{display:inline-block}.nsm7Bb-HzV7m-LgbsSe{-webkit-border-radius:4px;border-radius:4px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:background-color .218s,border-color .218s;transition:background-color .218s,border-color .218s;-webkit-user-select:none;-webkit-appearance:none;background-color:#fff;background-image:none;border:1px solid #dadce0;color:#3c4043;cursor:pointer;font-family:\"Google Sans\",arial,sans-serif;font-size:14px;height:40px;letter-spacing:0.25px;outline:none;overflow:hidden;padding:0 12px;position:relative;text-align:center;vertical-align:middle;white-space:nowrap;width:auto}@media screen and (-ms-high-contrast:active){.nsm7Bb-HzV7m-LgbsSe{border:2px solid windowText;color:windowText}}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe{font-size:14px;height:32px;letter-spacing:0.25px;padding:0 10px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe{font-size:11px;height:20px;letter-spacing:0.3px;padding:0 8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe{padding:0;width:40px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe{width:32px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe{width:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK{-webkit-border-radius:20px;border-radius:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.pSzOP-SxQuSe{-webkit-border-radius:16px;border-radius:16px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.purZT-SxQuSe{-webkit-border-radius:10px;border-radius:10px}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc{border:none;color:#fff}.nsm7Bb-HzV7m-LgbsSe.MFS4be-v3pZbf-Ia7Qfc{background-color:#1a73e8}.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{background-color:#202124;color:#e8eaed}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:18px;margin-right:8px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:14px;min-width:14px;width:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:10px;min-width:10px;width:10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin-left:8px;margin-right:-4px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:10px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:4px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;display:-webkit-box;display:-webkit-flex;display:flex;justify-content:center;-webkit-align-items:center;align-items:center;background-color:#fff;height:36px;margin-left:-10px;margin-right:12px;min-width:36px;width:36px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c,.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:28px;margin-left:-8px;margin-right:10px;min-width:28px;width:28px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:16px;margin-left:-6px;margin-right:8px;min-width:16px;width:16px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:3px;border-radius:3px;margin-left:2px;margin-right:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:14px;border-radius:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:8px;border-radius:8px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;-webkit-flex-direction:row;flex-direction:row;justify-content:space-between;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;height:100%;position:relative;width:100%}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX{justify-content:center}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:1;flex-grow:1;font-family:\"Google Sans\",arial,sans-serif;font-weight:500;overflow:hidden;text-overflow:ellipsis;vertical-align:top}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-weight:300}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:0;flex-grow:0}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-MJoBVe{-webkit-transition:background-color .218s;transition:background-color .218s;bottom:0;left:0;position:absolute;right:0;top:0}.nsm7Bb-HzV7m-LgbsSe:hover,.nsm7Bb-HzV7m-LgbsSe:focus{-webkit-box-shadow:none;box-shadow:none;border-color:#d2e3fc;outline:none}.nsm7Bb-HzV7m-LgbsSe:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.04)}.nsm7Bb-HzV7m-LgbsSe:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.1)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.24)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.32)}.nsm7Bb-HzV7m-LgbsSe .n1UuX-DkfjY{-webkit-border-radius:50%;border-radius:50%;display:-webkit-box;display:-webkit-flex;display:flex;height:20px;margin-left:-4px;margin-right:8px;min-width:20px;width:20px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-family:\"Roboto\";font-size:12px;text-align:left}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .ssJRIf,.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .fmcmS{overflow:hidden;text-overflow:ellipsis}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;color:#5f6368;fill:#5f6368;font-size:11px;font-weight:400}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#e8eaed;fill:#e8eaed}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .Bz112c{height:18px;margin:-3px -3px -3px 2px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:0;border-top-left-radius:0;-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;margin-left:12px;margin-right:-10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}sentinel{}\n/*# sourceURL=/_/gsi/_/ss/k=gsi.gsi.NTcghGmIfTA.L.W.O/am=AEQkLpoD/d=1/rs=AF0KOtUsyLLq24WfQ0VvOXlIyr7T-94kYw/m=credential_button_library */"]],["BODY",{"class":"qJTHM"},["DIV",{"id":"container","class":"haAclf"},["DIV",{"tabindex":"0","role":"button","aria-labelledby":"button-label","class":"nsm7Bb-HzV7m-LgbsSe  hJDwNd-SxQuSe MFS4be-JaPV2b-Ia7Qfc MFS4be-Ia7Qfc JGcpL-RbRzK"},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-MJoBVe"}],["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb "},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf"},["DIV",{"class":"nsm7Bb-HzV7m-LgbsSe-Bz112c"},["svg",{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 48 48","class":"LgbsSe-Bz112c"},["g",{},["path",{"fill":"#EA4335","d":"M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"}],["path",{"fill":"#4285F4","d":"M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"}],["path",{"fill":"#FBBC05","d":"M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"}],["path",{"fill":"#34A853","d":"M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"}],["path",{"fill":"none","d":"M0 0h48v48H0z"}]]]]],["SPAN",{"class":"nsm7Bb-HzV7m-LgbsSe-BPrWId"},"Inloggen"],["SPAN",{"class":"L6cTce","id":"button-label"},"Inloggen met Google"]]]]]],"viewport":{"width":0,"height":0},"timestamp":1295.363,"wallTime":1732730794364,"collectionTime":0.7000000476837158,"resourceOverrides":[],"isMainFrame":false}}
{"type":"before","callId":"call@49","startTime":1300.444,"apiName":"page.waitForEvent","class":"Page","method":"waitForEventInfo","params":{"info":{"waitId":"fa1928bb91b98cec6b90b3cfbc757c6a","phase":"before","event":"popup"}},"stepId":"pw:api@22","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@49"}
{"type":"log","callId":"call@49","time":1301.342,"message":"waiting for event \"popup\""}
{"type":"before","callId":"call@53","startTime":1301.5720000000001,"apiName":"page.waitForSelector","class":"Frame","method":"waitForSelector","params":{"selector":"iframe[title=\"Knop Inloggen met Google\"]"},"stepId":"pw:api@23","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@53"}
{"type":"frame-snapshot","snapshot":{"callId":"call@49","snapshotName":"before@call@49","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":[[1,96]],"viewport":{"width":1280,"height":720},"timestamp":1302.965,"wallTime":1732730794374,"collectionTime":0.39999985694885254,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@49","snapshotName":"before@call@49","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":[[1,28]],"viewport":{"width":0,"height":0},"timestamp":1303.952,"wallTime":1732730794375,"collectionTime":0.7000000476837158,"resourceOverrides":[],"isMainFrame":false}}
{"type":"frame-snapshot","snapshot":{"callId":"call@53","snapshotName":"before@call@53","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":[[2,96]],"viewport":{"width":1280,"height":720},"timestamp":1304.31,"wallTime":1732730794375,"collectionTime":0.3000001907348633,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@53","snapshotName":"before@call@53","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":[[2,28]],"viewport":{"width":0,"height":0},"timestamp":1304.495,"wallTime":1732730794375,"collectionTime":0.09999990463256836,"resourceOverrides":[],"isMainFrame":false}}
{"type":"log","callId":"call@53","time":1308.534,"message":"waiting for locator('iframe[title=\"Knop Inloggen met Google\"]') to be visible"}
{"type":"log","callId":"call@53","time":1318.997,"message":"  locator resolved to hidden <iframe id=\"gsi_794130_195463\" allow=\"identity-credentials-get\" title=\"Knop Inloggen met Google\" src=\"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ\"></iframe>"}
{"type":"log","callId":"call@53","time":1322.44,"message":"  locator resolved to hidden <iframe id=\"gsi_794130_195463\" allow=\"identity-credentials-get\" title=\"Knop Inloggen met Google\" src=\"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ\"></iframe>"}
{"type":"log","callId":"call@53","time":1352.162,"message":"  locator resolved to hidden <iframe id=\"gsi_794130_195463\" allow=\"identity-credentials-get\" title=\"Knop Inloggen met Google\" src=\"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ\"></iframe>"}
{"type":"console","messageType":"error","text":"Provider's accounts list is empty.","args":[],"location":{"url":"https://localhost:5173/","lineNumber":0,"columnNumber":0},"time":1368.715,"pageId":"page@57aeb351975ac179faea29c390bc1a4b"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794469.jpeg","width":1280,"height":720,"timestamp":1398.07,"frameSwapWallTime":1732730794464.489}
{"type":"log","callId":"call@53","time":1406.153,"message":"  locator resolved to visible <iframe id=\"gsi_794130_195463\" allow=\"identity-credentials-get\" title=\"Knop Inloggen met Google\" src=\"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ\"></iframe>"}
{"type":"after","callId":"call@53","endTime":1408.661,"result":{"element":"<ElementHandle>"},"afterSnapshot":"after@call@53"}
{"type":"frame-snapshot","snapshot":{"callId":"call@53","snapshotName":"after@call@53","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":["HTML",{"lang":"en","data-theme":"mytheme"},[[3,25]],[[3,26]],["BODY",{},[[3,27]],["DIV",{"id":"root"},["DIV",{"class":"h-[100vh] overflow-hidden"},[[3,59]],["DIV",{"class":"w-full full-screen-container"},["DIV",{"class":"relative overflow-hidden h-[100vh]"},["DIV",{"class":" mx-auto grid grid-cols-12 gap-5 px-6 md:px-8"},["DIV",{"class":"col-span-12 md:col-span-3 z-[1] "},[[3,61]],[[3,63]],["DIV",{"class":"py-8"},["DIV",{"id":"signInContainer","class":"z-[1]"},["DIV",{"id":"signInDiv"},["DIV",{"class":"S9gUrf-YoZ4jf","style":"position: relative;"},["DIV"],["IFRAME",{"src":"/snapshot/frame@95e7e8d29a071e743298104c5fcd78ce","allow":"identity-credentials-get","id":"gsi_794130_195463","title":"Knop Inloggen met Google","style":"display: block; position: relative; top: 0px; left: 0px; height: 44px; width: 141px; border: 0px; margin: -2px -10px;"}]]]]]]],[[3,88]]]]]],[[3,93]],[[3,94]]]],"viewport":{"width":1280,"height":720},"timestamp":1410.382,"wallTime":1732730794481,"collectionTime":0.40000009536743164,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@53","snapshotName":"after@call@53","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":["HTML",{"lang":"nl"},[[3,9]],["BODY",{"class":"qJTHM"},["DIV",{"id":"container","class":"haAclf","style":"padding: 2px 10px;"},[[3,25]]]]],"viewport":{"width":141,"height":44},"timestamp":1410.6779999999999,"wallTime":1732730794481,"collectionTime":0.20000004768371582,"resourceOverrides":[],"isMainFrame":false}}
{"type":"before","callId":"call@55","startTime":1413.101,"apiName":"locator.click","class":"Frame","method":"click","params":{"selector":"iframe[title=\"Knop Inloggen met Google\"] >> internal:control=enter-frame >> internal:label=\"Inloggen met Google\"i","strict":true},"stepId":"pw:api@24","pageId":"page@57aeb351975ac179faea29c390bc1a4b","beforeSnapshot":"before@call@55"}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"before@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":[[1,13]],"viewport":{"width":1280,"height":720},"timestamp":1414.407,"wallTime":1732730794485,"collectionTime":0.20000004768371582,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"before@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":[[1,2]],"viewport":{"width":141,"height":44},"timestamp":1414.842,"wallTime":1732730794485,"collectionTime":0.20000004768371582,"resourceOverrides":[],"isMainFrame":false}}
{"type":"log","callId":"call@55","time":1415.783,"message":"waiting for locator('iframe[title=\"Knop Inloggen met Google\"]').contentFrame().getByLabel('Inloggen met Google')"}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794488.jpeg","width":1280,"height":720,"timestamp":1416.466,"frameSwapWallTime":1732730794481.8079}
{"type":"log","callId":"call@55","time":1428.626,"message":"  locator resolved to <div tabindex=\"0\" role=\"button\" aria-labelledby=\"button-label\" class=\"nsm7Bb-HzV7m-LgbsSe  hJDwNd-SxQuSe MFS4be-JaPV2b-Ia7Qfc MFS4be-Ia7Qfc JGcpL-RbRzK\">…</div>"}
{"type":"log","callId":"call@55","time":1430.133,"message":"attempting click action"}
{"type":"log","callId":"call@55","time":1430.79,"message":"  waiting for element to be visible, enabled and stable"}
{"type":"log","callId":"call@55","time":1437.642,"message":"  element is visible, enabled and stable"}
{"type":"log","callId":"call@55","time":1437.692,"message":"  scrolling into view if needed"}
{"type":"log","callId":"call@55","time":1438.286,"message":"  done scrolling"}
{"type":"input","callId":"call@55","point":{"x":92.37,"y":468},"inputSnapshot":"input@call@55"}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"input@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":[[2,13]],"viewport":{"width":1280,"height":720},"timestamp":1442.188,"wallTime":1732730794512,"collectionTime":0.5,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"input@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":["HTML",{"lang":"nl"},[[5,9]],["BODY",{"class":"qJTHM"},["DIV",{"id":"container","class":"haAclf","style":"padding: 2px 10px;"},["DIV",{"__playwright_target__":"call@55","tabindex":"0","role":"button","aria-labelledby":"button-label","class":"nsm7Bb-HzV7m-LgbsSe  hJDwNd-SxQuSe MFS4be-JaPV2b-Ia7Qfc MFS4be-Ia7Qfc JGcpL-RbRzK"},[[5,10]],[[5,24]]]]]],"viewport":{"width":141,"height":44},"timestamp":1442.253,"wallTime":1732730794512,"collectionTime":0.20000004768371582,"resourceOverrides":[],"isMainFrame":false}}
{"type":"log","callId":"call@55","time":1449.556,"message":"  performing click action"}
{"type":"log","callId":"call@55","time":1453.53,"message":"  click action done"}
{"type":"log","callId":"call@55","time":1453.5819999999999,"message":"  waiting for scheduled navigations to finish"}
{"type":"log","callId":"call@55","time":1454.1680000000001,"message":"  navigations have finished"}
{"type":"after","callId":"call@55","endTime":1454.309,"point":{"x":92.37,"y":468},"afterSnapshot":"after@call@55"}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"after@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@8f8fa0dec058031ac23085ab178a1699","frameUrl":"https://localhost:5173/","doctype":"html","html":[[3,13]],"viewport":{"width":1280,"height":720},"timestamp":1455.584,"wallTime":1732730794526,"collectionTime":0.2999999523162842,"resourceOverrides":[],"isMainFrame":true}}
{"type":"frame-snapshot","snapshot":{"callId":"call@55","snapshotName":"after@call@55","pageId":"page@57aeb351975ac179faea29c390bc1a4b","frameId":"frame@95e7e8d29a071e743298104c5fcd78ce","frameUrl":"https://accounts.google.com/gsi/button?size=large&text=signin&shape=pill&theme=filled_black&client_id=367820938286-u0u38i2711n088ttaikh6s6td31pegjd.apps.googleusercontent.com&iframe_id=gsi_794130_195463&as=fFakYuGoV0%2B4RZmCEKpjpQ","doctype":"html","html":[[1,3]],"viewport":{"width":141,"height":44},"timestamp":1455.828,"wallTime":1732730794526,"collectionTime":0.2999999523162842,"resourceOverrides":[],"isMainFrame":false}}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794538.jpeg","width":1280,"height":720,"timestamp":1466.705,"frameSwapWallTime":1732730794533.201}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794551.jpeg","width":1280,"height":720,"timestamp":1479.94,"frameSwapWallTime":1732730794546.4949}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794568.jpeg","width":1280,"height":720,"timestamp":1496.809,"frameSwapWallTime":1732730794563.479}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794585.jpeg","width":1280,"height":720,"timestamp":1513.507,"frameSwapWallTime":1732730794580.19}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794618.jpeg","width":1280,"height":720,"timestamp":1546.6190000000001,"frameSwapWallTime":1732730794613.3152}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794668.jpeg","width":1280,"height":720,"timestamp":1596.637,"frameSwapWallTime":1732730794663.275}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794719.jpeg","width":1280,"height":720,"timestamp":1647.7820000000002,"frameSwapWallTime":1732730794714.2961}
{"type":"screencast-frame","pageId":"page@57aeb351975ac179faea29c390bc1a4b","sha1":"page@57aeb351975ac179faea29c390bc1a4b-1732730794769.jpeg","width":1280,"height":720,"timestamp":1698.181,"frameSwapWallTime":1732730794764.868}
